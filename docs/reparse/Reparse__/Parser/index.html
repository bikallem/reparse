<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (reparse.Reparse__.Parser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">reparse</a> &#x00BB; <a href="../index.html">Reparse__</a> &#x00BB; Parser</nav><h1>Module <code>Reparse__.Parser</code></h1><nav class="toc"><ul><li><a href="#overview">Overview</a><ul><li><a href="#types">Types</a></li><li><a href="#executing_samples">Executing Samples</a></li><li><a href="#parse">Parse</a></li><li><a href="#exception">Exception</a></li></ul></li><li><a href="#pure">Pure</a></li><li><a href="#concatenation/monad-combinators">Concatenation/Monad combinators</a></li><li><a href="#infix">Infix</a></li><li><a href="#alternation">Alternation</a></li><li><a href="#repetition">Repetition</a><ul><li><a href="#recur">Recur</a></li><li><a href="#skip">Skip</a></li><li><a href="#take">Take</a></li></ul></li><li><a href="#optional">Optional</a></li><li><a href="#query-input-state">Query Input state</a></li><li><a href="#boolean">Boolean</a></li><li><a href="#text">Text</a></li><li><a href="#rfc5234">RFC 5234</a></li></ul></nav></header><section><header><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2></header><aside><p>Parser provides functions and types to construct robust, performant and reusable parsers.</p><p>At the core is a type <a href="index.html#type-t"><code>t</code></a> which represents a constructed parser definition. A parser <a href="index.html#type-t"><code>t</code></a> is defined by composing together one or more parsers or <a href="index.html#type-t"><code>t</code></a>s via usage of parser operators.</p><p>An instance of <a href="index.html#type-t"><code>t</code></a> represents an un-evaluated parser. Use <a href="index.html#val-parse"><code>parse</code></a> function to evaluate it.</p><p><a href="class-type-input/index.html"><code>input</code></a> represents a generalization of data input to <a href="index.html#val-parse"><code>parse</code></a>. Implement the interface to create new input types.</p><p>Parser operators - or functions - are broadly organized into following categories:</p><ul><li>Pure</li><li>Concatentation</li><li>Alternation</li><li>Grouping</li><li>Repetition</li><li>Optional</li><li>Query input state</li><li>Boolean</li><li>Text</li><li>RFC 5234 core parsers</li></ul><p>An <a href="#infix">Infix</a> module contains infix and let syntax support functions.</p><p>See <a href="#examples">examples</a> of use.</p></aside><section><header><h3 id="types"><a href="#types" class="anchor"></a>Types</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>Represents a parser which can parse value <code>'a</code>.</p><p>Use <a href="#parse">parse functions</a> to evaluate a parser.</p></dd></dl><dl><dt class="spec class-type" id="class-type-input"><a href="#class-type-input" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span>  <a href="class-type-input/index.html">input</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></dt><dd><p>Represents a generalization of data input source to a parser. Implement this interface to provide new sources of input to <a href="index.html#val-parse"><code>parse</code></a>.</p></dd></dl></section><section><header><h3 id="executing_samples"><a href="#executing_samples" class="anchor"></a>Executing Samples</h3></header><aside><p>Include the <code>reparse</code> package in <code>utop</code>.</p><p>Copy and paste the sample in utop and type <code>;;</code> to run it.</p><pre>#require &quot;reparse&quot;;;</pre></aside></section><section><header><h3 id="parse"><a href="#parse" class="anchor"></a>Parse</h3><p>Evaluate a parser.</p></header><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : <span>?&#8288;track_lnum:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse_string ~track_lnum p s</code> evaluates <code>p</code> to value <code>v</code> while consuming string instance <code>s</code>.</p><p>If <code>track_num</code> is <code>true</code> then the parser tracks both the <em>line</em> and the <em>column</em> numbers. It is set to <code>false</code> by default.</p><p>Line number and column number both start count from <code>1</code> if enabled, <code>0</code> otherwise.</p><p><i>Also see</i> <a href="index.html#val-lnum"><code>lnum</code></a> and <a href="index.html#val-cnum"><code>cnum</code></a>.</p><h5 id="parse_examples"><a href="#parse_examples" class="anchor"></a>Examples</h5><p>Track line and column number</p><pre><code class="ml">module P = Reparse.Parser
open P

;;
let s = &quot;hello world&quot; in
let p = P.(take next *&gt; map2 (fun lnum cnum -&gt; lnum, cnum) lnum cnum) in
let v = P.parse_string ~track_lnum:true p s in
v = (1, 12)</code></pre><p>Default behaviour - doesn't track line, column number.</p><pre><code class="ml">module P = Reparse.Parser
open P

;;
let s = &quot;hello world&quot; in
let p = P.(take next *&gt; map2 (fun lnum cnum -&gt; lnum, cnum) lnum cnum) in
let v = P.parse_string p s in
v = (0, 0)</code></pre><dl><dt>raises Parser</dt><dd><p>when parser encounters error</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span>?&#8288;track_lnum:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="class-type-input/index.html">input</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse</code> is a generalised version of <a href="index.html#val-parse_string"><code>parse_string</code></a> over type <a href="class-type-input/index.html"><code>input</code></a>.</p><p>Use this function when you have a custom implementation of <a href="class-type-input/index.html"><code>input</code></a>.</p></dd></dl></section><section><header><h3 id="exception"><a href="#exception" class="anchor"></a>Exception</h3></header><dl><dt class="spec exception" id="exception-Parser"><a href="#exception-Parser" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Parser</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id=".offset" class="anchored"><td class="def field"><a href="#.offset" class="anchor"></a><code>offset : int;</code></td></tr><tr id=".line_number" class="anchored"><td class="def field"><a href="#.line_number" class="anchor"></a><code>line_number : int;</code></td></tr><tr id=".column_number" class="anchored"><td class="def field"><a href="#.column_number" class="anchor"></a><code>column_number : int;</code></td></tr><tr id=".msg" class="anchored"><td class="def field"><a href="#.msg" class="anchor"></a><code>msg : string;</code></td></tr></table><code>}</code></dt><dd><p>Raised by parsers which are unable to parse successfully.</p><p><code>offset</code> is the current index position of input at the time of failure.</p><p><code>line_number</code> is line number at the time of failure.</p><p><code>column_number</code> is column number at the time of failure.</p><p><code>msg</code> contains an error description.</p></dd></dl></section></section><section><header><h2 id="pure"><a href="#pure" class="anchor"></a>Pure</h2><p>Create parsers from values.</p></header><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>pure v</code> always parses value <code>v</code>.</p><h5 id="pure_examples"><a href="#pure_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let input = new P.string_input &quot;&quot; in
let v1 = P.(parse input (pure 5)) in
let v2 = P.(parse input (pure &quot;hello&quot;)) in
v1 = 5 &amp;&amp; v2 = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unit</code> is a convenience function to create a new parser which always parses to value <code>()</code>.</p><p><code>unit</code> is <code>pure ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fail err_msg</code> returns a parser that always fails with <code>err_msg</code>.</p><h5 id="fail_examples"><a href="#fail_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let input = new P.string_input &quot;&quot; in
let r =
  try
    let _ = P.(parse input (fail &quot;hello error&quot;)) in
    assert false
  with
  | e -&gt; e
in
r = P.Parser { offset = 0; line_number = 0; column_number = 0; msg = &quot;hello error&quot; }</code></pre></dd></dl></section><section><header><h2 id="concatenation/monad-combinators"><a href="#concatenation/monad-combinators" class="anchor"></a>Concatenation/Monad combinators</h2><p>Define parsers by joining two or more parsers.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Base.Applicative.S <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../index.html#module-Parser">Parser</a>.t</span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-both"><a href="#val-both" class="anchor"></a><code><span class="keyword">val</span> both : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-(*&gt;)"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span>unit <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt></dl><div class="spec module" id="module-Applicative_infix"><a href="#module-Applicative_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Applicative_infix/index.html">Applicative_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Base.Monad.S <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../index.html#module-Parser">Parser</a>.t</span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt></dl><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div></section><section><header><h2 id="infix"><a href="#infix" class="anchor"></a>Infix</h2></header><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Provides functions to support infix and let syntax operators.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="index.html#module-Infix">Infix</a></code></span></summary><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;&gt;= f</code> returns a new parser b where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Also known as <code>bind</code> operation.</p><h5 id="infix_bind_examples"><a href="#infix_bind_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let f a = P.pure (Char.code a) in
let p = P.char 'h' in
let p = p &gt;&gt;= f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;&gt;| f</code> returns a new parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code>.</li><li><code>b</code> is <code>f a</code>.</li></ul><p>Also known as <code>map</code> operation.</p><h5 id="infix_map_examples"><a href="#infix_map_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let f a = Char.code a in
let p = P.char 'h' in
let p = p &gt;&gt;| f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></dd></dl><dl><dt class="spec value" id="val-(&gt;|=)"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;|= f</code> returns a new parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code>.</li><li><code>b</code> is <code>f a</code>.</li></ul><p>Also known as <code>map</code> operation.</p><h5 id="infix_map_examples"><a href="#infix_map_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let f a = Char.code a in
let p = P.char 'h' in
let p = p &gt;|= f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>pf &lt;*&gt; q</code> returns a new parser encapsulating value <code>b</code> where</p><ul><li><code>pf</code> and <code>q</code> are evaluated sequentially in order as given.</li><li><code>f</code> is the parsed value of <code>pf</code></li><li><code>a</code> is the parsed value of <code>q</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Also known as <code>Applicative</code> operation.</p><h5 id="infix_applicative_examples"><a href="#infix_applicative_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let f a = a + 2 in
let pf = P.pure f in
let q = P.pure 2 in
let p = pf &lt;*&gt; q in
let v = P.parse_string p &quot;hello&quot; in
v = 4</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;$)"><a href="#val-(&lt;$)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$) : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>v &lt;$ p</code> replaces the parse value of <code>p</code> with <code>v</code>.</p><h5 id="infix_replace_examples"><a href="#infix_replace_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let v = &quot;hello&quot; in
let p = P.char 'h' in
let p = v &lt;$ p in
let v2 = P.parse_string p &quot;hello&quot; in
v2 = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>f &lt;$&gt; p</code> returns a parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>This is the infix version of <a href="index.html#val-map"><code>map</code></a>.</p><h5 id="infix_mapper_examples"><a href="#infix_mapper_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let f a = a ^ &quot; world&quot; in
let p = P.string &quot;hello&quot; in
let p = f &lt;$&gt; p in
let v = P.parse_string p &quot;hello&quot; in
v = &quot;hello world&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(*&gt;)"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p *&gt; q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>, <code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is parsed value of <code>q</code>.</li><li>The parsed value of <code>p</code> is discarded.</li></ul><p>Also known as <code>discard left</code>.</p><h5 id="infix_discard_left_examples"><a href="#infix_discard_left_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.string &quot;world&quot; in
let q = P.pure &quot;hello&quot; in
let p = p *&gt; q in
let v = P.parse_string p &quot;world&quot; in
v = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;* q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>, <code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is parsed value of <code>p</code>.</li><li>The parsed value of <code>q</code> is discarded.</li></ul><p>Also know as discard_right.</p><h5 id="infix_discard_right_examples"><a href="#infix_discard_right_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.string &quot;world&quot; in
let q = P.pure &quot;hello&quot; in
let p = p &lt;* q in
let v = P.parse_string p &quot;world&quot; in
v = &quot;world&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;|&gt;)"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;|&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;|&gt; q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>,<code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is the parsed value of <code>p</code> if <code>p</code> is successful</li><li><code>a</code> is the parsed value of <code>q</code> if <code>p</code> is a failure and <code>q</code> is a success.</li><li>If both - <code>p</code> and <code>q</code> - fails, then the parser fails.</li></ul><h5 id="infix_alternate_examples"><a href="#infix_alternate_examples" class="anchor"></a>Examples</h5><p><code>p</code> fails and <code>q</code> succeeds, therefore we return <code>q</code>'s parsed value <code>'w'</code></p><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v = P.parse_string p &quot;world&quot; in
v = 'w'</code></pre><p><code>p</code> succeeds therefore we return its parsed value <code>'h'</code></p><pre><code class="ml">let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre><p>The parser fails if both <code>p</code> and <code>q</code> fails.</p><pre><code class="ml">let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v =
  try
    let _ = P.parse_string p &quot;&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;?&gt; err_msg</code> parses <code>p</code> to value <code>a</code> and returns a new parser encapsulating <code>a</code>. If <code>p</code> is a failure, then it fails with error message <code>err_msg</code>.</p><p>Often used as a last choice in <code>&lt;|&gt;</code>, e.g. <code>a &lt;|&gt; b &lt;|&gt; c &lt;?&gt; &quot;expected a b c&quot;</code>.</p><h5 id="infix_error_named_examples"><a href="#infix_error_named_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.char 'h' &lt;|&gt; P.char 'w' in
let err_msg = &quot;[error]&quot; in
let p = p &lt;?&gt; err_msg in
let v =
  try
    let _ = P.parse_string p &quot;&quot; in
    false
  with
  | P.Parser { offset = 0; line_number = 0; column_number = 0; msg = &quot;[error]&quot; }
    -&gt; true
  | _ -&gt; false
in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>let*</code> is a let syntax binding for <a href="index.html#val-(&gt;&gt;=)"><code>(&gt;&gt;=)</code></a></p><h5 id="infix_let_bind_examples"><a href="#infix_let_bind_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p =
  let* a = P.pure 5 in
  let total = a + 5 in
  P.pure total
in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></dd></dl><dl><dt class="spec value" id="val-and*"><a href="#val-and*" class="anchor"></a><code><span class="keyword">val</span> and* : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span class="keyword">val</span> let+ : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>let*</code> is a let syntax binding for <a href="index.html#val-(&gt;|=)"><code>(&gt;|=)</code></a></p><h5 id="infix_let_map_examples"><a href="#infix_let_map_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p =
  let+ a = P.pure 5 in
  let total = a + 5 in
  total
in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></dd></dl><dl><dt class="spec value" id="val-and+"><a href="#val-and+" class="anchor"></a><code><span class="keyword">val</span> and+ : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span class="keyword">val</span> delay : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> Stdlib.Lazy.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>delay p</code> returns a parser which lazily parses <code>p</code>.</p><h5 id="delay_examples"><a href="#delay_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(delay (lazy (char 'z')) &lt;|&gt; delay (lazy (char 'a'))) in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre></dd></dl><dl><dt class="spec value" id="val-named"><a href="#val-named" class="anchor"></a><code><span class="keyword">val</span> named : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>named name p</code> uses <code>name</code> as part of an error message when constructing exception <a href="index.html#exception-Parser"><code>Parser</code></a> if parse of <code>p</code> fails.</p><p>Also see <a href="Infix/index.html#val-(&lt;?&gt;)"><code>Infix.(&lt;?&gt;)</code></a></p><h5 id="named_examples"><a href="#named_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(char 'a' |&gt; named &quot;parse_c&quot;) in
let v =
  try
    let _ = P.parse_string p &quot;zzd&quot; in
    assert false
  with
  | e -&gt; e
in
v
= P.Parser
    { offset = 0
    ; line_number = 0
    ; column_number = 0
    ; msg = &quot;[parse_c] Reparse.Parser.Parser(0, 0, 0, \&quot;[char] expected 'a'\&quot;)&quot;
    }</code></pre></dd></dl></section><section><header><h2 id="alternation"><a href="#alternation" class="anchor"></a>Alternation</h2><p>One or the other.</p></header><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>any l</code> parses the value of the first successful parser in list <code>l</code>.</p><p>Specified parsers in <code>l</code> are evaluated sequentially from left to right. A failed parser doesn't consume any input, i.e. <code>offset</code> is unaffected.</p><p>The parser fails if none of the parsers in <code>l</code> are evaluated successfully.</p><h5 id="any_examples"><a href="#any_examples" class="anchor"></a>Examples</h5><p>First successful parser result is returned</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;zabc&quot; in
v = 'z'

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;xabc&quot; in
v = 'x'

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre><p>Parser fails when none of the parsers in <code>l</code> are successful.</p><pre><code class="ml">let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v =
  try
    let _ = P.parse_string p &quot;yyy&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span class="keyword">val</span> alt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>alt p q</code> is <code>p &lt;|&gt; q</code>.</p><p>See <a href="Infix/index.html#val-(&lt;|&gt;)"><code>Infix.(&lt;|&gt;)</code></a></p></dd></dl></section><section><header><h2 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h2></header><section><header><h3 id="recur"><a href="#recur" class="anchor"></a>Recur</h3></header><dl><dt class="spec value" id="val-recur"><a href="#val-recur" class="anchor"></a><code><span class="keyword">val</span> recur : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>recur f</code> returns a recursive parser. Function value <code>f</code> accepts a parser <code>p</code> as its argument and returns a parser <code>q</code>. Parser <code>q</code> in its definition can refer to <code>p</code> and <code>p</code> can refer to <code>q</code> in its own definition.</p><p>Such parsers are also known as a fixpoint or y combinator.</p></dd></dl></section><section><header><h3 id="skip"><a href="#skip" class="anchor"></a>Skip</h3><p>Discards parsed values.</p></header><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <span>?&#8288;at_least:int</span> <span>&#45;&gt;</span> <span>?&#8288;up_to:int</span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip ~at_least ~up_to p</code> repeatedly parses <code>p</code> and discards its value.</p><p>The lower and upper bound of repetition is specified by arguments <code>at_least</code> and <code>up_to</code> respectively. The default value of <code>at_least</code> is 0. The default value of <code>up_to</code> is unspecified, i.e. there is no upper limit.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>up_to</code> upper bound value is reached</li></ul><p>The parser encapsulates the count of times <code>p</code> was evaluated successfully.</p><h5 id="skip_examples"><a href="#skip_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(skip space) in
let v = P.parse_string p &quot;     &quot; in
v = 5</code></pre></dd></dl><dl><dt class="spec value" id="val-skip_while"><a href="#val-skip_while" class="anchor"></a><code><span class="keyword">val</span> skip_while : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_while p ~while_</code> repeatedly parses <code>p</code> and discards its value if parser <code>while_</code> parses to value <code>true</code>.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li></ul><p><b>Note</b> <code>while_</code> does not consume input.</p><p>The parser encapsulates the count of times <code>p</code> was evaluated successfully.</p><h5 id="skip_while_examples"><a href="#skip_while_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(skip_while next ~while_:(is space)) in
let v = P.parse_string p &quot;     &quot; in
v = 5</code></pre></dd></dl></section><section><header><h3 id="take"><a href="#take" class="anchor"></a>Take</h3><p>Collects parsed values</p></header><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span>?&#8288;at_least:int</span> <span>&#45;&gt;</span> <span>?&#8288;up_to:int</span> <span>&#45;&gt;</span> <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take ~at_least ~up_to ~sep_by p</code> repeatedly parses <code>p</code> and returns the parsed values.</p><p>The lower and upper bound of repetition is specified by arguments <code>at_least</code> and <code>up_to</code> respectively. The default value of <code>at_least</code> is <code>0</code>. The default value of <code>up_to</code> is unspecified, i.e. there is no upper limit.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>sep_by</code> evaluates to failure</li><li><code>up_to</code> upper boudn value is reached</li></ul><p>The parser fails if the count of repetition of <code>p</code> does not match the value specified by <code>at_least</code>.</p><h5 id="take_examples"><a href="#take_examples" class="anchor"></a>Examples</h5><p>Default behaviour.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take (char 'a')) in
let v = P.parse_string p &quot;aaaaa&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Specify <code>~sep_by</code>.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Specify lower bound argument <code>at_least</code>.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take ~at_least:3 ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Lower bound not met results in error.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take ~at_least:5 ~sep_by:(char ',') (char 'a')) in
let v =
  try
    let _ = P.parse_string p &quot;a,a,a,a&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre><p>Specify upper bound <code>up_to</code>.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take ~up_to:3 ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take_while ~sep_by p ~while_ p</code> repeatedly parses <code>p</code> and returns its value.</p><p><code>p</code> is evaluated if and only if <code>while_</code> evaluates to <code>true</code>.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li><li><code>sep_by</code> evaluates to failure</li></ul><p><b>Note</b> <code>while_</code> does not consume input.</p><h5 id="take_while_examples"><a href="#take_while_examples" class="anchor"></a>Examples</h5><p>Default behaviour.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take_while ~while_:(is_not (char 'b')) (char 'a')) in
let v = P.parse_string p &quot;aab&quot; in
v = [ 'a'; 'a' ]</code></pre><p>Specify <code>sep_by</code>.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take_while ~sep_by:(char ',') ~while_:(is_not (char 'b')) (char 'a')) in
let v = P.parse_string p &quot;a,a,ab&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-take_between"><a href="#val-take_between" class="anchor"></a><code><span class="keyword">val</span> take_between : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>start:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>end_:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take_between ~sep_by ~start ~end_ p</code> parses <code>start</code> and then repeatedly parses <code>p</code> while the parsed value of <code>p</code> doesn't equal to parsed value of <code>end_</code>. After the repetition end, it parses <code>end_</code>. The parser returns the list of parsed values of <code>p</code>.</p><p>Both <code>start</code> and <code>end_</code> parser values are discarded.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>end_</code> parsed value matches <code>p</code> parsed value</li><li><code>sep_by</code> evaluates to failure</li></ul><h5 id="take_between_examples"><a href="#take_between_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p =
  P.(take_between ~sep_by:(char ',') ~start:(P.char '(') ~end_:(char ')') next)
in
let v = P.parse_string p &quot;(a,a,a)&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-take_while_cb"><a href="#val-take_while_cb" class="anchor"></a><code><span class="keyword">val</span> take_while_cb : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>on_take_cb:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take_while_on ~sep_by ~while_ ~on_take p</code> repeatedly parses <code>p</code> and calls callback <code>on_take_cb</code> with the parsed value.</p><p><code>p</code> is evaluated if and only if <code>while_</code> evaluates to <code>true</code>.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p><code>p</code> is evaluated repeatedly. The repetition ends when one of the following occurs:</p><p><code>on_take_cb</code> is the callback function that is called every time <code>p</code> is evaluated.</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li><li><code>sep_by</code> evaluates to failure</li></ul><p><code>take_while_cb</code> is the general version of <a href="index.html#val-take_while"><code>take_while</code></a>. It allows to specify how the value <code>a</code> is to be collected.</p><p><b>Note</b> <code>while_</code> does not consume input.</p><h5 id="take_while_cb_examples"><a href="#take_while_cb_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let buf = Buffer.create 0 in
let on_take_cb a = Buffer.add_char buf a in
let p = P.(take_while_cb (char 'a') ~while_:(is_not (char 'b')) ~on_take_cb) in
let v = P.parse_string p &quot;aaab&quot; in
let s = Buffer.contents buf in
v = 3 &amp;&amp; s = &quot;aaa&quot;</code></pre></dd></dl></section></section><section><header><h2 id="optional"><a href="#optional" class="anchor"></a>Optional</h2><p>Don't fail when parsing is not successful.</p></header><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>optional p</code> parses <code>Some a</code> if successful and <code>None</code> otherwise. <code>a</code> is the parsed value of <code>p</code>.</p><h5 id="optional_examples"><a href="#optional_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(optional (char 'a')) in
let v = P.parse_string p &quot;ab&quot; in
v = Some 'a'

;;
let p = P.(optional (char 'z')) in
let v = P.parse_string p &quot;ab&quot; in
v = None</code></pre></dd></dl></section><section><header><h2 id="query-input-state"><a href="#query-input-state" class="anchor"></a>Query Input state</h2></header><dl><dt class="spec value" id="val-is_eoi"><a href="#val-is_eoi" class="anchor"></a><code><span class="keyword">val</span> is_eoi : <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>is_eoi</code> parses to <code>true</code> if parser has reached end of input, <code>false</code> otherwise.</p><h5 id="is_eoi_examples"><a href="#is_eoi_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string is_eoi &quot;&quot;) in
v = true

;;
let v = P.(parse_string is_eoi &quot;a&quot;) in
v = false</code></pre></dd></dl><dl><dt class="spec value" id="val-eoi"><a href="#val-eoi" class="anchor"></a><code><span class="keyword">val</span> eoi : <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>eoi</code> parses end of input. Fails if parser is not at end of input.</p><h5 id="eoi_examples"><a href="#eoi_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string eoi &quot;&quot;) in
v = ()

;;
let v =
  try
    let _ = P.(parse_string eoi &quot;a&quot;) in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-lnum"><a href="#val-lnum" class="anchor"></a><code><span class="keyword">val</span> lnum : <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>lnum</code> parses the current line number of input. line number count start form <code>1</code>.</p><h5 id="lnum_examples"><a href="#lnum_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(next *&gt; lnum) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 1</code></pre></dd></dl><dl><dt class="spec value" id="val-cnum"><a href="#val-cnum" class="anchor"></a><code><span class="keyword">val</span> cnum : <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cnum</code> parses the current column number. column number count start from <code>1</code>.</p><h5 id="cnum_examples"><a href="#cnum_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(next *&gt; cnum) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 2</code></pre></dd></dl><dl><dt class="spec value" id="val-offset"><a href="#val-offset" class="anchor"></a><code><span class="keyword">val</span> offset : <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>offset</code> parses the current input offset. offset count start from <code>0</code>.</p><h5 id="offset_examples"><a href="#offset_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(next *&gt; offset) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 1</code></pre></dd></dl></section><section><header><h2 id="boolean"><a href="#boolean" class="anchor"></a>Boolean</h2><p><code>true</code>, <code>false</code>, is, is not.</p></header><dl><dt class="spec value" id="val-not_"><a href="#val-not_" class="anchor"></a><code><span class="keyword">val</span> not_ : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>not_ p</code> parses value <code>()</code> if and only if <code>p</code> fails to parse, otherwise the parse fails.</p><h5 id="not__examples"><a href="#not__examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(not_ (char 'a')) in
let v = P.parse_string p &quot;bbb&quot; in
v = ()</code></pre></dd></dl><dl><dt class="spec value" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>not_followed_by p q</code> parses value of <code>p</code> only if immediate and subsequent parse of <code>q</code> is a failure. Parser <code>q</code> doesn't consumes any input.</p><h5 id="not_followed_by_examples"><a href="#not_followed_by_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(not_followed_by (char 'a') (char 'a')) in
let v = P.parse_string p &quot;ab&quot; in
v = 'a'</code></pre></dd></dl><dl><dt class="spec value" id="val-is_not"><a href="#val-is_not" class="anchor"></a><code><span class="keyword">val</span> is_not : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>is_not p</code> parses value <code>true</code> if <code>p</code> fails to parse and <code>false</code> otherwise. <b>Note</b> evaluating <code>p</code> doesn't consume any input.</p><h5 id="is_not_examples"><a href="#is_not_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(is_not (char 'a')) in
let v = P.parse_string p &quot;bbb&quot; in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-is"><a href="#val-is" class="anchor"></a><code><span class="keyword">val</span> is : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>is p</code> parses <code>true</code> if <code>p</code> is successful, <code>false</code> otherwise. <b>Note</b> evaluation of <code>p</code> doesn't consume any input.</p><h5 id="is_examples"><a href="#is_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(is (char 'b')) in
let v = P.parse_string p &quot;bcb&quot; in
v = true</code></pre></dd></dl></section><section><header><h2 id="text"><a href="#text" class="anchor"></a>Text</h2><p>Text parsing.</p></header><dl><dt class="spec value" id="val-peek_char"><a href="#val-peek_char" class="anchor"></a><code><span class="keyword">val</span> peek_char : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>peek_char t</code> parses the next character from input without consuming it.</p><h5 id="peek_char_examples"><a href="#peek_char_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.peek_char in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre><p>Input is not consumed.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(peek_char *&gt; offset) in
let v = P.parse_string p &quot;hello&quot; in
v = 0</code></pre></dd></dl><dl><dt class="spec value" id="val-peek_string"><a href="#val-peek_string" class="anchor"></a><code><span class="keyword">val</span> peek_string : int <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>peek_string n</code> parse a string of length <code>n</code> without consuming it.</p><h5 id="peek_string_examples"><a href="#peek_string_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.peek_string 5 in
let v = P.parse_string p &quot;hello&quot; in
v = &quot;hello&quot;</code></pre><p>Input is not consumed.</p><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(peek_string 5 *&gt; offset) in
let v = P.parse_string p &quot;hello&quot; in
v = 0</code></pre></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>next</code> parses the next character from input. Fails if input has reached end of input.</p><h5 id="next_examples"><a href="#next_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string next &quot;hello&quot;) in
v = 'h'</code></pre></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>char c</code> parses character <code>c</code> exactly.</p><h5 id="char_examples"><a href="#char_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.char 'h' in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre></dd></dl><dl><dt class="spec value" id="val-char_if"><a href="#val-char_if" class="anchor"></a><code><span class="keyword">val</span> char_if : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>char_if f</code> parses a character <code>c</code> if <code>f c</code> is <code>true</code>.</p><h5 id="char_if_examples"><a href="#char_if_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p =
  P.char_if (function
      | 'a' -&gt; true
      | _ -&gt; false)
in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>string ~case_sensitive s</code> parses a string <code>s</code> exactly.</p><p>If <code>case_sensitive</code> is <code>false</code> then comparison is done without character case consideration. Default value is <code>true</code>.</p><h5 id="string_examples"><a href="#string_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.string &quot;hello&quot; in
let v = P.parse_string p &quot;hello world&quot; in
v = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-string_of_chars"><a href="#val-string_of_chars" class="anchor"></a><code><span class="keyword">val</span> string_of_chars : <span>char list</span> <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>string_of_chars l</code> converts <code>char list</code> <code>l</code> to string</p><h5 id="string_of_chars_examples"><a href="#string_of_chars_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take ~sep_by:space next &gt;&gt;= string_of_chars) in
let v = P.parse_string p &quot;h e l l o&quot; in
v = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-line"><a href="#val-line" class="anchor"></a><code><span class="keyword">val</span> line : <span>[ `LF <span>| `CRLF</span> ]</span> <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>line c</code> parses a line of text from input.</p><p>Line delimiter <code>c</code> can be either <code>`LF</code> or <code>`CRLF</code>. This corresponds to <code>\n</code> or <code>\r\n</code> character respectively.</p><h5 id="line_examples"><a href="#line_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.line `CRLF in
let v = P.parse_string p &quot;line1\r\nline2&quot; in
v = &quot;line1&quot;</code></pre></dd></dl></section><section><header><h2 id="rfc5234"><a href="#rfc5234" class="anchor"></a>RFC 5234</h2><p>Parsers as defined in RFC 5234, Appendix B.1.</p><dl><dt>see <a href="https://tools.ietf.org/html/rfc5234#appendix-B">https://tools.ietf.org/html/rfc5234#appendix-B</a></dt><dd></dd></dl></header><dl><dt class="spec value" id="val-alpha"><a href="#val-alpha" class="anchor"></a><code><span class="keyword">val</span> alpha : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>alpha</code> parses a character in range <code>A- Z</code> or <code>a-z</code>.</p><h5 id="alpha_examples"><a href="#alpha_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(take alpha) in
let v = P.parse_string p &quot;abcdABCD&quot; in
v = [ 'a'; 'b'; 'c'; 'd'; 'A'; 'B'; 'C'; 'D' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-alpha_num"><a href="#val-alpha_num" class="anchor"></a><code><span class="keyword">val</span> alpha_num : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>alpha_num</code> parses a character in range <code>A-Z</code> or <code>a-z</code> or <code>0-9</code>.</p><h5 id="alpha_num_examples"><a href="#alpha_num_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(take alpha_num) in
let v = P.parse_string p &quot;ab123ABCD&quot; in
v = [ 'a'; 'b'; '1'; '2'; '3'; 'A'; 'B'; 'C'; 'D' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-lower_alpha"><a href="#val-lower_alpha" class="anchor"></a><code><span class="keyword">val</span> lower_alpha : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>lower_alpha</code> parses a character in range <code>a-z</code>.</p><h5 id="lower_alpha_examples"><a href="#lower_alpha_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(take lower_alpha) in
let v = P.parse_string p &quot;abcd&quot; in
v = [ 'a'; 'b'; 'c'; 'd' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-upper_alpha"><a href="#val-upper_alpha" class="anchor"></a><code><span class="keyword">val</span> upper_alpha : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>upper_alpha</code> parses a character in range <code>A-Z</code>.</p><h5 id="upper_alpha_examples"><a href="#upper_alpha_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P

;;
let p = P.(take upper_alpha) in
let v = P.parse_string p &quot;ABCD&quot; in
v = [ 'A'; 'B'; 'C'; 'D' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-bit"><a href="#val-bit" class="anchor"></a><code><span class="keyword">val</span> bit : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bit</code> parses a character which is either <code>'0'</code> or <code>'1'</code>.</p><h5 id="bit_examples"><a href="#bit_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take bit) in
let v = P.parse_string p &quot;0110 ab&quot; in
v = [ '0'; '1'; '1'; '0' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-ascii_char"><a href="#val-ascii_char" class="anchor"></a><code><span class="keyword">val</span> ascii_char : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>ascii_char</code> parses any US-ASCII character.</p><h5 id="ascii_char_examples"><a href="#ascii_char_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take ascii_char) in
let v = P.parse_string p &quot;0110 abc '&quot; in
v = [ '0'; '1'; '1'; '0'; ' '; 'a'; 'b'; 'c'; ' '; '\'' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-cr"><a href="#val-cr" class="anchor"></a><code><span class="keyword">val</span> cr : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cr</code> parses character <code>'\r'</code>.</p><h5 id="cr_examples"><a href="#cr_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string cr &quot;\rab&quot;) in
v = '\r'</code></pre></dd></dl><dl><dt class="spec value" id="val-crlf"><a href="#val-crlf" class="anchor"></a><code><span class="keyword">val</span> crlf : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>crlf</code> parses string <code>&quot;\r\n&quot;</code>.</p><h5 id="crlf_examples"><a href="#crlf_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string crlf &quot;\r\n abc&quot;) in
v = &quot;\r\n&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-control"><a href="#val-control" class="anchor"></a><code><span class="keyword">val</span> control : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>control</code> parses characters in range <code>0x00 - 0x1F</code> or character <code>0x7F</code>.</p><h5 id="control_examples"><a href="#control_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string control &quot;\x00&quot;) in
v = '\x00'</code></pre></dd></dl><dl><dt class="spec value" id="val-digit"><a href="#val-digit" class="anchor"></a><code><span class="keyword">val</span> digit : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>digit</code> parses one of the digit characters, <code>0 .. 9</code>.</p><h5 id="digit_examples"><a href="#digit_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take digit) in
let v = P.parse_string p &quot;0123456789a&quot; in
v = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-digits"><a href="#val-digits" class="anchor"></a><code><span class="keyword">val</span> digits : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>digits</code> parses one or more digit characters, <code>0 .. 9</code>.</p><h5 id="digits_examples"><a href="#digits_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string digits &quot;1234 +&quot;) in
v = &quot;1234&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-dquote"><a href="#val-dquote" class="anchor"></a><code><span class="keyword">val</span> dquote : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>dquote</code> parses double quote character <code>'&quot;'</code>.</p><h5 id="dquote_examples"><a href="#dquote_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string dquote &quot;\&quot;hello &quot;) in
v = '&quot;'</code></pre></dd></dl><dl><dt class="spec value" id="val-hex_digit"><a href="#val-hex_digit" class="anchor"></a><code><span class="keyword">val</span> hex_digit : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>hex_digit</code> parses any of the hexadecimal digits - <code>0..9, A, B, C, D, E, F</code>.</p><h5 id="hex_digit_examples"><a href="#hex_digit_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take hex_digit) in
let v = P.parse_string p &quot;0ABCDEFa&quot; in
v = [ '0'; 'A'; 'B'; 'C'; 'D'; 'E'; 'F' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-htab"><a href="#val-htab" class="anchor"></a><code><span class="keyword">val</span> htab : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>htab</code> parses a horizontal tab character <code>'\t'</code>.</p><h5 id="htab_examples"><a href="#htab_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string htab &quot;\t&quot;) in
v = '\t'</code></pre></dd></dl><dl><dt class="spec value" id="val-lf"><a href="#val-lf" class="anchor"></a><code><span class="keyword">val</span> lf : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>lf</code> parses a linefeed <code>'\n'</code> character.</p><h5 id="lf_examples"><a href="#lf_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string lf &quot;\n&quot;) in
v = '\n'</code></pre></dd></dl><dl><dt class="spec value" id="val-octet"><a href="#val-octet" class="anchor"></a><code><span class="keyword">val</span> octet : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>octect</code> parses any character in the range <code>\x00 - \xFF</code>. Synonym for <a href="index.html#val-next"><code>next</code></a></p><h5 id="octet_examples"><a href="#octet_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take octet) in
let v = P.parse_string p &quot;0110 abc '&quot; in
v = [ '0'; '1'; '1'; '0'; ' '; 'a'; 'b'; 'c'; ' '; '\'' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-space"><a href="#val-space" class="anchor"></a><code><span class="keyword">val</span> space : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>space</code> parses a space character.</p><h5 id="space_examples"><a href="#space_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string space &quot; abc '&quot;) in
v = ' '</code></pre></dd></dl><dl><dt class="spec value" id="val-spaces"><a href="#val-spaces" class="anchor"></a><code><span class="keyword">val</span> spaces : <span><span>char list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>spaces</code> parses one or more spaces.</p><h5 id="spaces_examples"><a href="#spaces_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let v = P.(parse_string spaces &quot;   abc&quot;) in
v = [ ' '; ' '; ' ' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-vchar"><a href="#val-vchar" class="anchor"></a><code><span class="keyword">val</span> vchar : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>vchar</code> parses any of the visible - printable - characters.</p><h5 id="vchar_examples"><a href="#vchar_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take vchar) in
let v = P.parse_string p &quot;0110abc\x00&quot; in
v = [ '0'; '1'; '1'; '0'; 'a'; 'b'; 'c' ]</code></pre></dd></dl><dl><dt class="spec value" id="val-whitespace"><a href="#val-whitespace" class="anchor"></a><code><span class="keyword">val</span> whitespace : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>whitespace</code> parses a space <code>' '</code> or horizontal tab <code>'\t'</code> character.</p><h5 id="whitespace_examples"><a href="#whitespace_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser

;;
let p = P.(take whitespace) in
let v = P.parse_string p &quot;\t \t &quot; in
v = [ '\t'; ' '; '\t'; ' ' ]</code></pre></dd></dl></section></div></body></html>