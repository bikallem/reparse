<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (reparse.Reparse.Parser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0-578-g42983a23"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">reparse</a> &#x00BB; <a href="../index.html">Reparse</a> &#x00BB; Parser</nav><header><h1>Module <code>Reparse.Parser</code></h1><dl><dt>deprecated</dt><dd><p><code>since v3.0.0</code> Use Reparse. All functions from Parser have been migrated to <code>Reparse</code> module</p></dd></dl></header><nav class="toc"><ul><li><a href="#overview">Overview</a><ul><li><a href="#types">Types</a></li><li><a href="#executing_samples">Executing Samples</a></li><li><a href="#parse">Parse</a></li><li><a href="#exception">Exception</a></li></ul></li><li><a href="#pure">Pure</a></li><li><a href="#concatenation/monad-combinators">Concatenation/Monad combinators</a></li><li><a href="#infix">Infix</a></li><li><a href="#alternation">Alternation</a></li><li><a href="#repetition">Repetition</a><ul><li><a href="#recur">Recur</a></li><li><a href="#skip">Skip</a></li><li><a href="#take">Take</a></li></ul></li><li><a href="#optional">Optional</a></li><li><a href="#query-input-state">Query Input state</a></li><li><a href="#boolean">Boolean</a></li><li><a href="#text">Text</a></li><li><a href="#rfc5234">RFC 5234</a></li></ul></nav><div class="content"><aside></aside><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><aside><p>Parser provides functions and types to construct robust, performant and reusable parsers.</p><p>At the core is a type <a href="../index.html#type-t"><code>Reparse.t</code></a> which represents a constructed parser definition. A parser <a href="../index.html#type-t"><code>Reparse.t</code></a> is defined by composing together one or more parsers or <a href="../index.html#type-t"><code>Reparse.t</code></a>s via usage of parser operators.</p><p>An instance of <a href="../index.html#type-t"><code>Reparse.t</code></a> represents an un-evaluated parser. Use <a href="../index.html#val-parse"><code>Reparse.parse</code></a> function to evaluate it.</p><p><a href="../class-type-input/index.html"><code>Reparse.input</code></a> represents a generalization of data input to <a href="../index.html#val-parse"><code>Reparse.parse</code></a>. Implement the interface to create new input types.</p><p>Parser operators - or functions - are broadly organized into following categories:</p><ul><li>Pure</li><li>Concatentation</li><li>Alternation</li><li>Grouping</li><li>Repetition</li><li>Optional</li><li>Query input state</li><li>Boolean</li><li>Text</li><li>RFC 5234 core parsers</li></ul><p>An <a href="#infix">Infix</a> module contains infix and let syntax support functions.</p><p>See <a href="#examples">examples</a> of use.</p></aside><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></div><div><p>Represents a parser which can parse value <code>'a</code>.</p><p>Use <a href="#parse">parse functions</a> to evaluate a parser.</p></div></div><div><div class="spec class-type" id="class-type-input" class="anchored"><a href="#class-type-input" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span>  <a href="class-type-input/index.html">input</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></div><div><p>Represents a generalization of data input source to a parser. Implement this interface to provide new sources of input to <a href="../index.html#val-parse"><code>Reparse.parse</code></a>.</p></div></div><h3 id="executing_samples"><a href="#executing_samples" class="anchor"></a>Executing Samples</h3><aside><p>Include the <code>reparse</code> package in <code>utop</code>.</p><p>Copy and paste the sample in utop and type <code>;;</code> to run it.</p><pre>#require &quot;reparse&quot;;;</pre></aside><h3 id="parse"><a href="#parse" class="anchor"></a>Parse</h3><aside><p>Evaluate a parser.</p></aside><div><div class="spec value" id="val-parse_string" class="anchored"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : <span>?&#8288;track_lnum:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><p><code>parse_string ~track_lnum p s</code> evaluates <code>p</code> to value <code>v</code> while consuming string instance <code>s</code>.</p><p>If <code>track_num</code> is <code>true</code> then the parser tracks both the <em>line</em> and the <em>column</em> numbers. It is set to <code>false</code> by default.</p><p>Line number and column number both start count from <code>1</code> if enabled, <code>0</code> otherwise.</p><p><i>Also see</i> <a href="../index.html#val-lnum"><code>Reparse.lnum</code></a> and <a href="../index.html#val-cnum"><code>Reparse.cnum</code></a>.</p><p>Examples</p><p>Track line and column number</p><pre><code>module P = Reparse.Parser
open P

;;
let s = &quot;hello world&quot; in
let p = P.(take next *&gt; map2 (fun lnum cnum -&gt; lnum, cnum) lnum cnum) in
let v = P.parse_string ~track_lnum:true p s in
v = (1, 12)</code></pre><p>Default behaviour - doesn't track line, column number.</p><pre><code>module P = Reparse.Parser
open P

;;
let s = &quot;hello world&quot; in
let p = P.(take next *&gt; map2 (fun lnum cnum -&gt; lnum, cnum) lnum cnum) in
let v = P.parse_string p s in
v = (0, 0)</code></pre><dl><dt>raises Parser</dt><dd><p>when parser encounters error</p></dd></dl></div></div><div><div class="spec value" id="val-parse" class="anchored"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span>?&#8288;track_lnum:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <a href="class-type-input/index.html">input</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><p><code>parse</code> is a generalised version of <a href="../index.html#val-parse_string"><code>Reparse.parse_string</code></a> over type <a href="../class-type-input/index.html"><code>Reparse.input</code></a>.</p><p>Use this function when you have a custom implementation of <a href="../class-type-input/index.html"><code>Reparse.input</code></a>.</p></div></div><h3 id="exception"><a href="#exception" class="anchor"></a>Exception</h3><div><div class="spec exception" id="exception-Parser" class="anchored"><a href="#exception-Parser" class="anchor"></a><code><span class="keyword">exception</span> <span class="exception">Parser</span> <span class="keyword">of</span> {</code><table><tr id="module-Parser.offset" class="anchored"><td class="def record field"><a href="#module-Parser.offset" class="anchor"></a><code>offset : int;</code></td></tr><tr id="module-Parser.line_number" class="anchored"><td class="def record field"><a href="#module-Parser.line_number" class="anchor"></a><code>line_number : int;</code></td></tr><tr id="module-Parser.column_number" class="anchored"><td class="def record field"><a href="#module-Parser.column_number" class="anchor"></a><code>column_number : int;</code></td></tr><tr id="module-Parser.msg" class="anchored"><td class="def record field"><a href="#module-Parser.msg" class="anchor"></a><code>msg : string;</code></td></tr></table><code>}</code></div><div><p>Raised by parsers which are unable to parse successfully.</p><p><code>offset</code> is the current index position of input at the time of failure.</p><p><code>line_number</code> is line number at the time of failure.</p><p><code>column_number</code> is column number at the time of failure.</p><p><code>msg</code> contains an error description.</p></div></div><h2 id="pure"><a href="#pure" class="anchor"></a>Pure</h2><aside><p>Create parsers from values.</p></aside><div><div class="spec value" id="val-pure" class="anchored"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>pure v</code> always parses value <code>v</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let input = new P.string_input &quot;&quot; in
let v1 = P.(parse input (pure 5)) in
let v2 = P.(parse input (pure &quot;hello&quot;)) in
v1 = 5 &amp;&amp; v2 = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit <a href="#type-t">t</a></span></code></div><div><p><code>unit</code> is a convenience function to create a new parser which always parses to value <code>()</code>.</p><p><code>unit</code> is <code>pure ()</code>.</p></div></div><div><div class="spec value" id="val-fail" class="anchored"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>fail err_msg</code> returns a parser that always fails with <code>err_msg</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let input = new P.string_input &quot;&quot; in
let r =
  try
    let _ = P.(parse input (fail &quot;hello error&quot;)) in
    assert false
  with
  | e -&gt; e
in
r = P.Parser { offset = 0; line_number = 0; column_number = 0; msg = &quot;hello error&quot; }</code></pre></div></div><h2 id="concatenation/monad-combinators"><a href="#concatenation/monad-combinators" class="anchor"></a>Concatenation/Monad combinators</h2><aside><p>Define parsers by joining two or more parsers.</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="xref-unresolved">Base</span>.Applicative.S <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <span class="xref-unresolved">t</span></span> := <span><span class="type-var">'a</span> <span class="xref-unresolved">t</span></span></code></span></summary><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span class="keyword">val</span> both : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-(&lt;*)" class="anchored"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-(*&gt;)" class="anchored"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span>unit <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-apply" class="anchored"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-map3" class="anchored"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="#type-t">t</a></span></code></div><div class="spec module" id="module-Applicative_infix" class="anchored"><a href="#module-Applicative_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Applicative_infix/index.html">Applicative_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="xref-unresolved">Base</span>.Monad.S <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <span class="xref-unresolved">t</span></span> := <span><span class="type-var">'a</span> <span class="xref-unresolved">t</span></span></code></span></summary><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></code></div><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="#type-t">t</a></span></code></div><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><h2 id="infix"><a href="#infix" class="anchor"></a>Infix</h2><div><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>Provides functions to support infix and let syntax operators.</p></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Infix/index.html">Infix</a></code></span></summary><div><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>p &gt;&gt;= f</code> returns a new parser b where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Also known as <code>bind</code> operation.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let f a = P.pure (Char.code a) in
let p = P.char 'h' in
let p = p &gt;&gt;= f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></div></div><div><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>p &gt;&gt;| f</code> returns a new parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code>.</li><li><code>b</code> is <code>f a</code>.</li></ul><p>Also known as <code>map</code> operation.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let f a = Char.code a in
let p = P.char 'h' in
let p = p &gt;&gt;| f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></div></div><div><div class="spec value" id="val-(&gt;|=)" class="anchored"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>p &gt;|= f</code> returns a new parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code>.</li><li><code>b</code> is <code>f a</code>.</li></ul><p>Also known as <code>map</code> operation.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let f a = Char.code a in
let p = P.char 'h' in
let p = p &gt;|= f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></div></div><div><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>pf &lt;*&gt; q</code> returns a new parser encapsulating value <code>b</code> where</p><ul><li><code>pf</code> and <code>q</code> are evaluated sequentially in order as given.</li><li><code>f</code> is the parsed value of <code>pf</code></li><li><code>a</code> is the parsed value of <code>q</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Also known as <code>Applicative</code> operation.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let f a = a + 2 in
let pf = P.pure f in
let q = P.pure 2 in
let p = pf &lt;*&gt; q in
let v = P.parse_string p &quot;hello&quot; in
v = 4</code></pre></div></div><div><div class="spec value" id="val-(&lt;$)" class="anchored"><a href="#val-(&lt;$)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$) : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>v &lt;$ p</code> replaces the parse value of <code>p</code> with <code>v</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let v = &quot;hello&quot; in
let p = P.char 'h' in
let p = v &lt;$ p in
let v2 = P.parse_string p &quot;hello&quot; in
v2 = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-(&lt;$&gt;)" class="anchored"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>f &lt;$&gt; p</code> returns a parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>This is the infix version of <code>Reparse</code>.Infix.map.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let f a = a ^ &quot; world&quot; in
let p = P.string &quot;hello&quot; in
let p = f &lt;$&gt; p in
let v = P.parse_string p &quot;hello&quot; in
v = &quot;hello world&quot;</code></pre></div></div><div><div class="spec value" id="val-(*&gt;)" class="anchored"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>p *&gt; q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>, <code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is parsed value of <code>q</code>.</li><li>The parsed value of <code>p</code> is discarded.</li></ul><p>Also known as <code>discard left</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.string &quot;world&quot; in
let q = P.pure &quot;hello&quot; in
let p = p *&gt; q in
let v = P.parse_string p &quot;world&quot; in
v = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-(&lt;*)" class="anchored"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>p &lt;* q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>, <code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is parsed value of <code>p</code>.</li><li>The parsed value of <code>q</code> is discarded.</li></ul><p>Also know as discard_right.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.string &quot;world&quot; in
let q = P.pure &quot;hello&quot; in
let p = p &lt;* q in
let v = P.parse_string p &quot;world&quot; in
v = &quot;world&quot;</code></pre></div></div><div><div class="spec value" id="val-(&lt;|&gt;)" class="anchored"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;|&gt;) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>p &lt;|&gt; q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>,<code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is the parsed value of <code>p</code> if <code>p</code> is successful</li><li><code>a</code> is the parsed value of <code>q</code> if <code>p</code> is a failure and <code>q</code> is a success.</li><li>If both - <code>p</code> and <code>q</code> - fails, then the parser fails.</li></ul><p>Examples</p><p><code>p</code> fails and <code>q</code> succeeds, therefore we return <code>q</code>'s parsed value <code>'w'</code></p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v = P.parse_string p &quot;world&quot; in
v = 'w'</code></pre><p><code>p</code> succeeds therefore we return its parsed value <code>'h'</code></p><pre><code>let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre><p>The parser fails if both <code>p</code> and <code>q</code> fails.</p><pre><code>let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v =
  try
    let _ = P.parse_string p &quot;&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><div><div class="spec value" id="val-(&lt;?&gt;)" class="anchored"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>p &lt;?&gt; err_msg</code> parses <code>p</code> to value <code>a</code> and returns a new parser encapsulating <code>a</code>. If <code>p</code> is a failure, then it fails with error message <code>err_msg</code>.</p><p>Often used as a last choice in <code>&lt;|&gt;</code>, e.g. <code>a &lt;|&gt; b &lt;|&gt; c &lt;?&gt; &quot;expected a b c&quot;</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.char 'h' &lt;|&gt; P.char 'w' in
let err_msg = &quot;[error]&quot; in
let p = p &lt;?&gt; err_msg in
let v =
  try
    let _ = P.parse_string p &quot;&quot; in
    false
  with
  | P.Parser { offset = 0; line_number = 0; column_number = 0; msg = &quot;[error]&quot; }
    -&gt; true
  | _ -&gt; false
in
v = true</code></pre></div></div><div><div class="spec value" id="val-let*" class="anchored"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>let*</code> is a let syntax binding for <a href="../Infix/index.html#val-(&gt;&gt;=)"><code>Reparse.Infix.(&gt;&gt;=)</code></a></p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p =
  let* a = P.pure 5 in
  let total = a + 5 in
  P.pure total
in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></div></div><div class="spec value" id="val-and*" class="anchored"><a href="#val-and*" class="anchor"></a><code><span class="keyword">val</span> and* : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></code></div><div><div class="spec value" id="val-let+" class="anchored"><a href="#val-let+" class="anchor"></a><code><span class="keyword">val</span> let+ : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></code></div><div><p><code>let*</code> is a let syntax binding for <a href="../index.html#val-(&gt;|=)"><code>Reparse.(&gt;|=)</code></a></p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p =
  let+ a = P.pure 5 in
  let total = a + 5 in
  total
in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></div></div><div class="spec value" id="val-and+" class="anchored"><a href="#val-and+" class="anchor"></a><code><span class="keyword">val</span> and+ : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></code></div></details></div></div></div><div><div class="spec value" id="val-delay" class="anchored"><a href="#val-delay" class="anchor"></a><code><span class="keyword">val</span> delay : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Lazy.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>delay p</code> returns a parser which lazily parses <code>p</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(delay (lazy (char 'z')) &lt;|&gt; delay (lazy (char 'a'))) in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre></div></div><div><div class="spec value" id="val-named" class="anchored"><a href="#val-named" class="anchor"></a><code><span class="keyword">val</span> named : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>named name p</code> uses <code>name</code> as part of an error message when constructing exception <a href="../index.html#exception-Parser"><code>Reparse.Parser</code></a> if parse of <code>p</code> fails.</p><p>Also see <a href="../Infix/index.html#val-(&lt;?&gt;)"><code>Reparse.Infix.(&lt;?&gt;)</code></a></p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(char 'a' |&gt; named &quot;parse_c&quot;) in
let v =
  try
    let _ = P.parse_string p &quot;zzd&quot; in
    assert false
  with
  | e -&gt; e
in
v
= P.Parser
    { offset = 0
    ; line_number = 0
    ; column_number = 0
    ; msg = &quot;[parse_c] Reparse.Parser.Parser(0, 0, 0, \&quot;[char] expected 'a'\&quot;)&quot;
    }</code></pre></div></div><h2 id="alternation"><a href="#alternation" class="anchor"></a>Alternation</h2><aside><p>One or the other.</p></aside><div><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>any l</code> parses the value of the first successful parser in list <code>l</code>.</p><p>Specified parsers in <code>l</code> are evaluated sequentially from left to right. A failed parser doesn't consume any input, i.e. <code>offset</code> is unaffected.</p><p>The parser fails if none of the parsers in <code>l</code> are evaluated successfully.</p><p>Examples</p><p>First successful parser result is returned</p><pre><code>module P = Reparse.Parser

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;zabc&quot; in
v = 'z'

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;xabc&quot; in
v = 'x'

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre><p>Parser fails when none of the parsers in <code>l</code> are successful.</p><pre><code>let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v =
  try
    let _ = P.parse_string p &quot;yyy&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><div><div class="spec value" id="val-alt" class="anchored"><a href="#val-alt" class="anchor"></a><code><span class="keyword">val</span> alt : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>alt p q</code> is <code>p &lt;|&gt; q</code>.</p><p>See <a href="../Infix/index.html#val-(&lt;|&gt;)"><code>Reparse.Infix.(&lt;|&gt;)</code></a></p></div></div><h2 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h2><h3 id="recur"><a href="#recur" class="anchor"></a>Recur</h3><div><div class="spec value" id="val-recur" class="anchored"><a href="#val-recur" class="anchor"></a><code><span class="keyword">val</span> recur : <span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>recur f</code> returns a recursive parser. Function value <code>f</code> accepts a parser <code>p</code> as its argument and returns a parser <code>q</code>. Parser <code>q</code> in its definition can refer to <code>p</code> and <code>p</code> can refer to <code>q</code> in its own definition.</p><p>Such parsers are also known as a fixpoint or y combinator.</p></div></div><h3 id="skip"><a href="#skip" class="anchor"></a>Skip</h3><aside><p>Discards parsed values.</p></aside><div><div class="spec value" id="val-skip" class="anchored"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <span>?&#8288;at_least:int</span> <span>&#45;&gt;</span> <span>?&#8288;up_to:int</span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="#type-t">t</a></span></code></div><div><p><code>skip ~at_least ~up_to p</code> repeatedly parses <code>p</code> and discards its value.</p><p>The lower and upper bound of repetition is specified by arguments <code>at_least</code> and <code>up_to</code> respectively. The default value of <code>at_least</code> is 0. The default value of <code>up_to</code> is unspecified, i.e. there is no upper limit.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>up_to</code> upper bound value is reached</li></ul><p>The parser encapsulates the count of times <code>p</code> was evaluated successfully.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(skip space) in
let v = P.parse_string p &quot;     &quot; in
v = 5</code></pre></div></div><div><div class="spec value" id="val-skip_while" class="anchored"><a href="#val-skip_while" class="anchor"></a><code><span class="keyword">val</span> skip_while : <span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>int <a href="#type-t">t</a></span></code></div><div><p><code>skip_while p ~while_</code> repeatedly parses <code>p</code> and discards its value if parser <code>while_</code> parses to value <code>true</code>.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li></ul><p><b>Note</b> <code>while_</code> does not consume input.</p><p>The parser encapsulates the count of times <code>p</code> was evaluated successfully.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(skip_while next ~while_:(is space)) in
let v = P.parse_string p &quot;     &quot; in
v = 5</code></pre></div></div><h3 id="take"><a href="#take" class="anchor"></a>Take</h3><aside><p>Collects parsed values</p></aside><div><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span>?&#8288;at_least:int</span> <span>&#45;&gt;</span> <span>?&#8288;up_to:int</span> <span>&#45;&gt;</span> <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></code></div><div><p><code>take ~at_least ~up_to ~sep_by p</code> repeatedly parses <code>p</code> and returns the parsed values.</p><p>The lower and upper bound of repetition is specified by arguments <code>at_least</code> and <code>up_to</code> respectively. The default value of <code>at_least</code> is <code>0</code>. The default value of <code>up_to</code> is unspecified, i.e. there is no upper limit.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>sep_by</code> evaluates to failure</li><li><code>up_to</code> upper boudn value is reached</li></ul><p>The parser fails if the count of repetition of <code>p</code> does not match the value specified by <code>at_least</code>.</p><p>Examples</p><p>Default behaviour.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take (char 'a')) in
let v = P.parse_string p &quot;aaaaa&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Specify <code>~sep_by</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Specify lower bound argument <code>at_least</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~at_least:3 ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Lower bound not met results in error.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~at_least:5 ~sep_by:(char ',') (char 'a')) in
let v =
  try
    let _ = P.parse_string p &quot;a,a,a,a&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre><p>Specify upper bound <code>up_to</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~up_to:3 ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></div></div><div><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></code></div><div><p><code>take_while ~sep_by p ~while_ p</code> repeatedly parses <code>p</code> and returns its value.</p><p><code>p</code> is evaluated if and only if <code>while_</code> evaluates to <code>true</code>.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li><li><code>sep_by</code> evaluates to failure</li></ul><p><b>Note</b> <code>while_</code> does not consume input.</p><p>Examples</p><p>Default behaviour.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take_while ~while_:(is_not (char 'b')) (char 'a')) in
let v = P.parse_string p &quot;aab&quot; in
v = [ 'a'; 'a' ]</code></pre><p>Specify <code>sep_by</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take_while ~sep_by:(char ',') ~while_:(is_not (char 'b')) (char 'a')) in
let v = P.parse_string p &quot;a,a,ab&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></div></div><div><div class="spec value" id="val-take_between" class="anchored"><a href="#val-take_between" class="anchor"></a><code><span class="keyword">val</span> take_between : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>start:<span><span class="type-var">_</span> <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>end_:<span><span class="type-var">_</span> <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></code></div><div><p><code>take_between ~sep_by ~start ~end_ p</code> parses <code>start</code> and then repeatedly parses <code>p</code> while the parsed value of <code>p</code> doesn't equal to parsed value of <code>end_</code>. After the repetition end, it parses <code>end_</code>. The parser returns the list of parsed values of <code>p</code>.</p><p>Both <code>start</code> and <code>end_</code> parser values are discarded.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>end_</code> parsed value matches <code>p</code> parsed value</li><li><code>sep_by</code> evaluates to failure</li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p =
  P.(take_between ~sep_by:(char ',') ~start:(P.char '(') ~end_:(char ')') next)
in
let v = P.parse_string p &quot;(a,a,a)&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></div></div><div><div class="spec value" id="val-take_while_cb" class="anchored"><a href="#val-take_while_cb" class="anchor"></a><code><span class="keyword">val</span> take_while_cb : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>on_take_cb:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="#type-t">t</a></span></code></div><div><p><code>take_while_on ~sep_by ~while_ ~on_take p</code> repeatedly parses <code>p</code> and calls callback <code>on_take_cb</code> with the parsed value.</p><p><code>p</code> is evaluated if and only if <code>while_</code> evaluates to <code>true</code>.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p><code>p</code> is evaluated repeatedly. The repetition ends when one of the following occurs:</p><p><code>on_take_cb</code> is the callback function that is called every time <code>p</code> is evaluated.</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li><li><code>sep_by</code> evaluates to failure</li></ul><p><code>take_while_cb</code> is the general version of <a href="../index.html#val-take_while"><code>Reparse.take_while</code></a>. It allows to specify how the value <code>a</code> is to be collected.</p><p><b>Note</b> <code>while_</code> does not consume input.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let buf = Buffer.create 0 in
let on_take_cb a = Buffer.add_char buf a in
let p = P.(take_while_cb (char 'a') ~while_:(is_not (char 'b')) ~on_take_cb) in
let v = P.parse_string p &quot;aaab&quot; in
let s = Buffer.contents buf in
v = 3 &amp;&amp; s = &quot;aaa&quot;</code></pre></div></div><h2 id="optional"><a href="#optional" class="anchor"></a>Optional</h2><aside><p>Don't fail when parsing is not successful.</p></aside><div><div class="spec value" id="val-optional" class="anchored"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></code></div><div><p><code>optional p</code> parses <code>Some a</code> if successful and <code>None</code> otherwise. <code>a</code> is the parsed value of <code>p</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(optional (char 'a')) in
let v = P.parse_string p &quot;ab&quot; in
v = Some 'a'

;;
let p = P.(optional (char 'z')) in
let v = P.parse_string p &quot;ab&quot; in
v = None</code></pre></div></div><h2 id="query-input-state"><a href="#query-input-state" class="anchor"></a>Query Input state</h2><div><div class="spec value" id="val-is_eoi" class="anchored"><a href="#val-is_eoi" class="anchor"></a><code><span class="keyword">val</span> is_eoi : <span>bool <a href="#type-t">t</a></span></code></div><div><p><code>is_eoi</code> parses to <code>true</code> if parser has reached end of input, <code>false</code> otherwise.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string is_eoi &quot;&quot;) in
v = true

;;
let v = P.(parse_string is_eoi &quot;a&quot;) in
v = false</code></pre></div></div><div><div class="spec value" id="val-eoi" class="anchored"><a href="#val-eoi" class="anchor"></a><code><span class="keyword">val</span> eoi : <span>unit <a href="#type-t">t</a></span></code></div><div><p><code>eoi</code> parses end of input. Fails if parser is not at end of input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string eoi &quot;&quot;) in
v = ()

;;
let v =
  try
    let _ = P.(parse_string eoi &quot;a&quot;) in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><div><div class="spec value" id="val-lnum" class="anchored"><a href="#val-lnum" class="anchor"></a><code><span class="keyword">val</span> lnum : <span>int <a href="#type-t">t</a></span></code></div><div><p><code>lnum</code> parses the current line number of input. line number count start form <code>1</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(next *&gt; lnum) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 1</code></pre></div></div><div><div class="spec value" id="val-cnum" class="anchored"><a href="#val-cnum" class="anchor"></a><code><span class="keyword">val</span> cnum : <span>int <a href="#type-t">t</a></span></code></div><div><p><code>cnum</code> parses the current column number. column number count start from <code>1</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(next *&gt; cnum) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 2</code></pre></div></div><div><div class="spec value" id="val-offset" class="anchored"><a href="#val-offset" class="anchor"></a><code><span class="keyword">val</span> offset : <span>int <a href="#type-t">t</a></span></code></div><div><p><code>offset</code> parses the current input offset. offset count start from <code>0</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(next *&gt; offset) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 1</code></pre></div></div><h2 id="boolean"><a href="#boolean" class="anchor"></a>Boolean</h2><aside><p><code>true</code>, <code>false</code>, is, is not.</p></aside><div><div class="spec value" id="val-not_" class="anchored"><a href="#val-not_" class="anchor"></a><code><span class="keyword">val</span> not_ : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="#type-t">t</a></span></code></div><div><p><code>not_ p</code> parses value <code>()</code> if and only if <code>p</code> fails to parse, otherwise the parse fails.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(not_ (char 'a')) in
let v = P.parse_string p &quot;bbb&quot; in
v = ()</code></pre></div></div><div><div class="spec value" id="val-not_followed_by" class="anchored"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></code></div><div><p><code>not_followed_by p q</code> parses value of <code>p</code> only if immediate and subsequent parse of <code>q</code> is a failure. Parser <code>q</code> doesn't consumes any input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(not_followed_by (char 'a') (char 'a')) in
let v = P.parse_string p &quot;ab&quot; in
v = 'a'</code></pre></div></div><div><div class="spec value" id="val-is_not" class="anchored"><a href="#val-is_not" class="anchor"></a><code><span class="keyword">val</span> is_not : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>bool <a href="#type-t">t</a></span></code></div><div><p><code>is_not p</code> parses value <code>true</code> if <code>p</code> fails to parse and <code>false</code> otherwise. <b>Note</b> evaluating <code>p</code> doesn't consume any input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(is_not (char 'a')) in
let v = P.parse_string p &quot;bbb&quot; in
v = true</code></pre></div></div><div><div class="spec value" id="val-is" class="anchored"><a href="#val-is" class="anchor"></a><code><span class="keyword">val</span> is : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span>&#45;&gt;</span> <span>bool <a href="#type-t">t</a></span></code></div><div><p><code>is p</code> parses <code>true</code> if <code>p</code> is successful, <code>false</code> otherwise. <b>Note</b> evaluation of <code>p</code> doesn't consume any input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(is (char 'b')) in
let v = P.parse_string p &quot;bcb&quot; in
v = true</code></pre></div></div><h2 id="text"><a href="#text" class="anchor"></a>Text</h2><aside><p>Text parsing.</p></aside><div><div class="spec value" id="val-peek_char" class="anchored"><a href="#val-peek_char" class="anchor"></a><code><span class="keyword">val</span> peek_char : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>peek_char t</code> parses the next character from input without consuming it.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.peek_char in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre><p>Input is not consumed.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(peek_char *&gt; offset) in
let v = P.parse_string p &quot;hello&quot; in
v = 0</code></pre></div></div><div><div class="spec value" id="val-peek_string" class="anchored"><a href="#val-peek_string" class="anchor"></a><code><span class="keyword">val</span> peek_string : int <span>&#45;&gt;</span> <span>string <a href="#type-t">t</a></span></code></div><div><p><code>peek_string n</code> parse a string of length <code>n</code> without consuming it.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.peek_string 5 in
let v = P.parse_string p &quot;hello&quot; in
v = &quot;hello&quot;</code></pre><p>Input is not consumed.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(peek_string 5 *&gt; offset) in
let v = P.parse_string p &quot;hello&quot; in
v = 0</code></pre></div></div><div><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>next</code> parses the next character from input. Fails if input has reached end of input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string next &quot;hello&quot;) in
v = 'h'</code></pre></div></div><div><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> <span>char <a href="#type-t">t</a></span></code></div><div><p><code>char c</code> parses character <code>c</code> exactly.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.char 'h' in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre></div></div><div><div class="spec value" id="val-char_if" class="anchored"><a href="#val-char_if" class="anchor"></a><code><span class="keyword">val</span> char_if : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span>char <a href="#type-t">t</a></span></code></div><div><p><code>char_if f</code> parses a character <code>c</code> if <code>f c</code> is <code>true</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p =
  P.char_if (function
      | 'a' -&gt; true
      | _ -&gt; false)
in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre></div></div><div><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string <a href="#type-t">t</a></span></code></div><div><p><code>string ~case_sensitive s</code> parses a string <code>s</code> exactly.</p><p>If <code>case_sensitive</code> is <code>false</code> then comparison is done without character case consideration. Default value is <code>true</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.string &quot;hello&quot; in
let v = P.parse_string p &quot;hello world&quot; in
v = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-string_of_chars" class="anchored"><a href="#val-string_of_chars" class="anchor"></a><code><span class="keyword">val</span> string_of_chars : <span>char list</span> <span>&#45;&gt;</span> <span>string <a href="#type-t">t</a></span></code></div><div><p><code>string_of_chars l</code> converts <code>char list</code> <code>l</code> to string</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~sep_by:space next &gt;&gt;= string_of_chars) in
let v = P.parse_string p &quot;h e l l o&quot; in
v = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-line" class="anchored"><a href="#val-line" class="anchor"></a><code><span class="keyword">val</span> line : <span>[ `LF <span>| `CRLF</span> ]</span> <span>&#45;&gt;</span> <span>string <a href="#type-t">t</a></span></code></div><div><p><code>line c</code> parses a line of text from input.</p><p>Line delimiter <code>c</code> can be either <code>`LF</code> or <code>`CRLF</code>. This corresponds to <code>\n</code> or <code>\r\n</code> character respectively.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.line `CRLF in
let v = P.parse_string p &quot;line1\r\nline2&quot; in
v = &quot;line1&quot;</code></pre></div></div><h2 id="rfc5234"><a href="#rfc5234" class="anchor"></a>RFC 5234</h2><aside><p>Parsers as defined in RFC 5234, Appendix B.1.</p><dl><dt>see <a href="https://tools.ietf.org/html/rfc5234#appendix-B">https://tools.ietf.org/html/rfc5234#appendix-B</a></dt><dd></dd></dl></aside><div><div class="spec value" id="val-alpha" class="anchored"><a href="#val-alpha" class="anchor"></a><code><span class="keyword">val</span> alpha : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>alpha</code> parses a character in range <code>A- Z</code> or <code>a-z</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(take alpha) in
let v = P.parse_string p &quot;abcdABCD&quot; in
v = [ 'a'; 'b'; 'c'; 'd'; 'A'; 'B'; 'C'; 'D' ]</code></pre></div></div><div><div class="spec value" id="val-alpha_num" class="anchored"><a href="#val-alpha_num" class="anchor"></a><code><span class="keyword">val</span> alpha_num : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>alpha_num</code> parses a character in range <code>A-Z</code> or <code>a-z</code> or <code>0-9</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(take alpha_num) in
let v = P.parse_string p &quot;ab123ABCD&quot; in
v = [ 'a'; 'b'; '1'; '2'; '3'; 'A'; 'B'; 'C'; 'D' ]</code></pre></div></div><div><div class="spec value" id="val-lower_alpha" class="anchored"><a href="#val-lower_alpha" class="anchor"></a><code><span class="keyword">val</span> lower_alpha : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>lower_alpha</code> parses a character in range <code>a-z</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(take lower_alpha) in
let v = P.parse_string p &quot;abcd&quot; in
v = [ 'a'; 'b'; 'c'; 'd' ]</code></pre></div></div><div><div class="spec value" id="val-upper_alpha" class="anchored"><a href="#val-upper_alpha" class="anchor"></a><code><span class="keyword">val</span> upper_alpha : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>upper_alpha</code> parses a character in range <code>A-Z</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P

;;
let p = P.(take upper_alpha) in
let v = P.parse_string p &quot;ABCD&quot; in
v = [ 'A'; 'B'; 'C'; 'D' ]</code></pre></div></div><div><div class="spec value" id="val-bit" class="anchored"><a href="#val-bit" class="anchor"></a><code><span class="keyword">val</span> bit : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>bit</code> parses a character which is either <code>'0'</code> or <code>'1'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take bit) in
let v = P.parse_string p &quot;0110 ab&quot; in
v = [ '0'; '1'; '1'; '0' ]</code></pre></div></div><div><div class="spec value" id="val-ascii_char" class="anchored"><a href="#val-ascii_char" class="anchor"></a><code><span class="keyword">val</span> ascii_char : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>ascii_char</code> parses any US-ASCII character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ascii_char) in
let v = P.parse_string p &quot;0110 abc '&quot; in
v = [ '0'; '1'; '1'; '0'; ' '; 'a'; 'b'; 'c'; ' '; '\'' ]</code></pre></div></div><div><div class="spec value" id="val-cr" class="anchored"><a href="#val-cr" class="anchor"></a><code><span class="keyword">val</span> cr : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>cr</code> parses character <code>'\r'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string cr &quot;\rab&quot;) in
v = '\r'</code></pre></div></div><div><div class="spec value" id="val-crlf" class="anchored"><a href="#val-crlf" class="anchor"></a><code><span class="keyword">val</span> crlf : <span>string <a href="#type-t">t</a></span></code></div><div><p><code>crlf</code> parses string <code>&quot;\r\n&quot;</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string crlf &quot;\r\n abc&quot;) in
v = &quot;\r\n&quot;</code></pre></div></div><div><div class="spec value" id="val-control" class="anchored"><a href="#val-control" class="anchor"></a><code><span class="keyword">val</span> control : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>control</code> parses characters in range <code>0x00 - 0x1F</code> or character <code>0x7F</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string control &quot;\x00&quot;) in
v = '\x00'</code></pre></div></div><div><div class="spec value" id="val-digit" class="anchored"><a href="#val-digit" class="anchor"></a><code><span class="keyword">val</span> digit : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>digit</code> parses one of the digit characters, <code>0 .. 9</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take digit) in
let v = P.parse_string p &quot;0123456789a&quot; in
v = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]</code></pre></div></div><div><div class="spec value" id="val-digits" class="anchored"><a href="#val-digits" class="anchor"></a><code><span class="keyword">val</span> digits : <span>string <a href="#type-t">t</a></span></code></div><div><p><code>digits</code> parses one or more digit characters, <code>0 .. 9</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string digits &quot;1234 +&quot;) in
v = &quot;1234&quot;</code></pre></div></div><div><div class="spec value" id="val-dquote" class="anchored"><a href="#val-dquote" class="anchor"></a><code><span class="keyword">val</span> dquote : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>dquote</code> parses double quote character <code>'&quot;'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string dquote &quot;\&quot;hello &quot;) in
v = '&quot;'</code></pre></div></div><div><div class="spec value" id="val-hex_digit" class="anchored"><a href="#val-hex_digit" class="anchor"></a><code><span class="keyword">val</span> hex_digit : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>hex_digit</code> parses any of the hexadecimal digits - <code>0..9, A, B, C, D, E, F</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take hex_digit) in
let v = P.parse_string p &quot;0ABCDEFa&quot; in
v = [ '0'; 'A'; 'B'; 'C'; 'D'; 'E'; 'F' ]</code></pre></div></div><div><div class="spec value" id="val-htab" class="anchored"><a href="#val-htab" class="anchor"></a><code><span class="keyword">val</span> htab : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>htab</code> parses a horizontal tab character <code>'\t'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string htab &quot;\t&quot;) in
v = '\t'</code></pre></div></div><div><div class="spec value" id="val-lf" class="anchored"><a href="#val-lf" class="anchor"></a><code><span class="keyword">val</span> lf : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>lf</code> parses a linefeed <code>'\n'</code> character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string lf &quot;\n&quot;) in
v = '\n'</code></pre></div></div><div><div class="spec value" id="val-octet" class="anchored"><a href="#val-octet" class="anchor"></a><code><span class="keyword">val</span> octet : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>octect</code> parses any character in the range <code>\x00 - \xFF</code>. Synonym for <a href="../index.html#val-next"><code>Reparse.next</code></a></p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take octet) in
let v = P.parse_string p &quot;0110 abc '&quot; in
v = [ '0'; '1'; '1'; '0'; ' '; 'a'; 'b'; 'c'; ' '; '\'' ]</code></pre></div></div><div><div class="spec value" id="val-space" class="anchored"><a href="#val-space" class="anchor"></a><code><span class="keyword">val</span> space : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>space</code> parses a space character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string space &quot; abc '&quot;) in
v = ' '</code></pre></div></div><div><div class="spec value" id="val-spaces" class="anchored"><a href="#val-spaces" class="anchor"></a><code><span class="keyword">val</span> spaces : <span><span>char list</span> <a href="#type-t">t</a></span></code></div><div><p><code>spaces</code> parses one or more spaces.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string spaces &quot;   abc&quot;) in
v = [ ' '; ' '; ' ' ]</code></pre></div></div><div><div class="spec value" id="val-vchar" class="anchored"><a href="#val-vchar" class="anchor"></a><code><span class="keyword">val</span> vchar : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>vchar</code> parses any of the visible - printable - characters.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take vchar) in
let v = P.parse_string p &quot;0110abc\x00&quot; in
v = [ '0'; '1'; '1'; '0'; 'a'; 'b'; 'c' ]</code></pre></div></div><div><div class="spec value" id="val-whitespace" class="anchored"><a href="#val-whitespace" class="anchor"></a><code><span class="keyword">val</span> whitespace : <span>char <a href="#type-t">t</a></span></code></div><div><p><code>whitespace</code> parses a space <code>' '</code> or horizontal tab <code>'\t'</code> character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take whitespace) in
let v = P.parse_string p &quot;\t \t &quot; in
v = [ '\t'; ' '; '\t'; ' ' ]</code></pre></div></div></div></body></html>