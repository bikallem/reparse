<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (reparse.Reparse.Parser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0-506-g81385c87"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">reparse</a> &#x00BB; <a href="../index.html">Reparse</a> &#x00BB; Parser</nav><header><h1>Module <code>Reparse.Parser</code></h1></header><nav class="toc"><ul><li><a href="#overview">Overview</a><ul><li><a href="#types">Types</a></li><li><a href="#executing_samples">Executing Samples</a></li><li><a href="#parse">Parse</a></li><li><a href="#exception">Exception</a></li></ul></li><li><a href="#pure">Pure</a></li><li><a href="#concatenation">Concatenation</a><ul><li><a href="#bind">Bind</a></li><li><a href="#map">Map</a></li></ul></li><li><a href="#alternation">Alternation</a></li><li><a href="#grouping">Grouping</a></li><li><a href="#repetition">Repetition</a><ul><li><a href="#recur">Recur</a></li><li><a href="#skip">Skip</a></li><li><a href="#take">Take</a></li></ul></li><li><a href="#optional">Optional</a></li><li><a href="#query-input-state">Query Input state</a></li><li><a href="#boolean">Boolean</a></li><li><a href="#text">Text</a></li><li><a href="#rfc5234">RFC 5234</a></li><li><a href="#infix">Infix</a></li><li><a href="#examples">Examples</a><ul><li><a href="#calculator">Calculator</a></li><li><a href="#json">Json</a></li></ul></li></ul></nav><div class="content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><aside><p>Parser provides functions and types to construct robust, performant and reusable parsers.</p><p>At the core is a type <a href="index.html#type-t"><code>t</code></a> which represents a constructed parser definition. A parser <a href="index.html#type-t"><code>t</code></a> is defined by composing together one or more parsers or <a href="index.html#type-t"><code>t</code></a>s via usage of parser operators.</p><p>An instance of <a href="index.html#type-t"><code>t</code></a> represents an un-evaluated parser. Use <a href="index.html#val-parse"><code>parse</code></a> function to evaluate it.</p><p><a href="class-type-input/index.html"><code>input</code></a> represents a generalization of data input to <a href="index.html#val-parse"><code>parse</code></a>. Implement the interface to create new input types.</p><p>Parser operators - or functions - are broadly organized into following categories:</p><ul><li>Pure</li><li>Concatentation</li><li>Alternation</li><li>Grouping</li><li>Repetition</li><li>Optional</li><li>Query input state</li><li>Boolean</li><li>Text</li><li>RFC 5234 core parsers</li></ul><p>An <a href="#infix">Infix</a> module contains infix and let syntax support functions.</p><p>See <a href="#examples">examples</a> of use.</p></aside><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></div><div><p>Represents a parser which can parse value <code>'a</code>.</p><p>Use <a href="#parse">parse functions</a> to evaluate a parser.</p></div></div><div><div class="spec class-type" id="class-type-input" class="anchored"><a href="#class-type-input" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span>  <a href="class-type-input/index.html">input</a><span class="keyword">object</span> ... <span class="keyword">end</span></code></div><div><p>Represents a generalization of data input source to a parser. Implement this interface to provide new sources of input to <a href="index.html#val-parse"><code>parse</code></a>.</p></div></div><h3 id="executing_samples"><a href="#executing_samples" class="anchor"></a>Executing Samples</h3><aside><p>Include the <code>reparse</code> package in <code>utop</code>.</p><p>Copy and paste the sample in utop and type <code>;;</code> to run it.</p><pre>#require &quot;reparse&quot;;;</pre></aside><h3 id="parse"><a href="#parse" class="anchor"></a>Parse</h3><aside><p>Evaluate a parser.</p></aside><div><div class="spec value" id="val-parse_string" class="anchored"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : <span>?&#8288;track_lnum:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><p><code>parse_string ~track_lnum p s</code> evaluates <code>p</code> to value <code>v</code> while consuming string instance <code>s</code>.</p><p>If <code>track_num</code> is <code>true</code> then the parser tracks both the <em>line</em> and the <em>column</em> numbers. It is set to <code>false</code> by default.</p><p>Line number and column number both start count from <code>1</code> if enabled, <code>0</code> otherwise.</p><p><i>Also see</i> <a href="index.html#val-lnum"><code>lnum</code></a> and <a href="index.html#val-cnum"><code>cnum</code></a>.</p><p>Examples</p><p>Track line and column number</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let s = &quot;hello world&quot; in
let p = P.(take next *&gt; map2 (fun lnum cnum -&gt; lnum, cnum) lnum cnum) in
let v = P.parse_string ~track_lnum:true p s in
v = (1, 12)</code></pre><p>Default behaviour - doesn't track line, column number.</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let s = &quot;hello world&quot; in
let p = P.(take next *&gt; map2 (fun lnum cnum -&gt; lnum, cnum) lnum cnum) in
let v = P.parse_string p s in
v = (0, 0)</code></pre><dl><dt>raises Parser</dt><dd><p>when parser encounters error</p></dd></dl></div></div><div><div class="spec value" id="val-parse" class="anchored"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span>?&#8288;track_lnum:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="class-type-input/index.html">input</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><p><code>parse</code> is a generalised version of <a href="index.html#val-parse_string"><code>parse_string</code></a> over type <a href="class-type-input/index.html"><code>input</code></a>.</p><p>Use this function when you have a custom implementation of <a href="class-type-input/index.html"><code>input</code></a>.</p></div></div><h3 id="exception"><a href="#exception" class="anchor"></a>Exception</h3><div><div class="spec exception" id="exception-Parser" class="anchored"><a href="#exception-Parser" class="anchor"></a><code><span class="keyword">exception</span> <span class="exception">Parser</span> <span class="keyword">of</span> {</code><table><tr id="module-Parser.offset" class="anchored"><td class="def record field"><a href="#module-Parser.offset" class="anchor"></a><code>offset : int;</code></td></tr><tr id="module-Parser.line_number" class="anchored"><td class="def record field"><a href="#module-Parser.line_number" class="anchor"></a><code>line_number : int;</code></td></tr><tr id="module-Parser.column_number" class="anchored"><td class="def record field"><a href="#module-Parser.column_number" class="anchor"></a><code>column_number : int;</code></td></tr><tr id="module-Parser.msg" class="anchored"><td class="def record field"><a href="#module-Parser.msg" class="anchor"></a><code>msg : string;</code></td></tr></table><code>}</code></div><div><p>Raised by parsers which are unable to parse successfully.</p><p><code>offset</code> is the current index position of input at the time of failure.</p><p><code>line_number</code> is line number at the time of failure.</p><p><code>column_number</code> is column number at the time of failure.</p><p><code>msg</code> contains an error description.</p></div></div><h2 id="pure"><a href="#pure" class="anchor"></a>Pure</h2><aside><p>Create parsers from values.</p></aside><div><div class="spec value" id="val-pure" class="anchored"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>pure v</code> always parses value <code>v</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let input = new P.string_input &quot;&quot; in
let v1 = P.(parse input (pure 5)) in
let v2 = P.(parse input (pure &quot;hello&quot;)) in
v1 = 5 &amp;&amp; v2 = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>unit</code> is a convenience function to create a new parser which always parses to value <code>()</code>.</p><p><code>unit</code> is <code>pure ()</code>.</p></div></div><div><div class="spec value" id="val-fail" class="anchored"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>fail err_msg</code> returns a parser that always fails with <code>err_msg</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let input = new P.string_input &quot;&quot; in
let r =
  try
    let _ = P.(parse input (fail &quot;hello error&quot;)) in
    assert false
  with
  | e -&gt; e
in
r = P.Parser { offset = 0; line_number = 0; column_number = 0; msg = &quot;hello error&quot; }</code></pre></div></div><h2 id="concatenation"><a href="#concatenation" class="anchor"></a>Concatenation</h2><aside><p>Define parsers by joining two or more parsers.</p></aside><h3 id="bind"><a href="#bind" class="anchor"></a>Bind</h3><div><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>bind p f</code> returns a new parser <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let f a = P.pure (a ^ &quot; world&quot;) in
let p = P.string &quot;hello&quot; in
let p = P.bind p f in
let input = new P.string_input &quot;hello&quot; in
let b = P.parse input p in
b = &quot;hello world&quot;</code></pre><p>See <a href="Infix/index.html#val-(&gt;&gt;=)"><code>Infix.(&gt;&gt;=)</code></a>. <code>p &gt;&gt;= f</code> is the infix equivalent of <code>bind p f</code>.</p></div></div><h3 id="map"><a href="#map" class="anchor"></a>Map</h3><aside><p>Mappers transform from one parser value to another. <code>map</code> functions <code>map2, map3, map4</code> are defined in terms of <a href="index.html#val-bind"><code>bind</code></a>s. So a given mapper function usage can be defined equivalently in terms of <a href="index.html#val-bind"><code>bind</code></a>s.</p></aside><div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map f p</code> returns a new parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code>.</li><li><code>b</code> is <code>f a</code>.</li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let f a = a ^ &quot; world&quot; in
let p = P.string &quot;hello&quot; in
let p = P.map f p in
let b = P.parse p &quot;hello&quot; in
b = &quot;hello world&quot;</code></pre><p>Since <code>map</code> is defined in terms of <code>bind</code>, the above usage of <code>map</code> is equivalent to the <code>bind</code> usage below,</p><pre><code>module P = Reparse.Parser

;;
let f a = P.pure (a ^ &quot; world&quot;) in
let p = P.string &quot;hello&quot; in
let p = P.bind p f in
let r = P.parse_string p &quot;hello&quot; in
r = &quot;hello world&quot;</code></pre><p>See <a href="Infix/index.html#val-(&lt;$&gt;)"><code>Infix.(&lt;$&gt;)</code></a>. <code>f &lt;$&gt; p</code> is infix equivalent of <code>map f p</code>.</p></div></div><div><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map2 f p q</code> returns a new parser encapsulating value <code>c</code> where,</p><ul><li><code>p</code> and <code>q</code> are evaluated sequentially in order as given.</li><li><code>a, b</code> are the parsed values of parsers <code>p</code> and <code>q</code> respectively.</li><li><code>c</code> is <code>f a b</code>.</li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let f a b = a + b in
let p = P.pure 1 in
let q = P.pure 2 in
let p = P.map2 f p q in
let v = P.parse_string p &quot;&quot; in
v = 3</code></pre><p>The above usage of <code>map2</code> is equivalent to below,</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.pure 1 &gt;&gt;= fun a -&gt; P.pure 2 &gt;&gt;= fun b -&gt; P.pure (a + b) in
let v = P.parse_string p &quot;&quot; in
v = 3</code></pre></div></div><div><div class="spec value" id="val-map3" class="anchored"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map3 f p q r</code> returns a new parser encapsulating value <code>d</code> where,</p><ul><li><code>p</code>, <code>q</code>, <code>r</code> are evaluated sequentially in order as given.</li><li><code>a, b, c</code> are the parsed values of parsers <code>p</code>, <code>q</code> and <code>r</code> respectively.</li><li><code>d</code> is <code>f a b c</code>.</li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let f a b c = a + b + c in
let p = P.pure 1 in
let q = P.pure 2 in
let r = P.pure 3 in
let p = P.map3 f p q r in
let v = P.parse_string p &quot;&quot; in
v = 6</code></pre></div></div><div><div class="spec value" id="val-map4" class="anchored"><a href="#val-map4" class="anchor"></a><code><span class="keyword">val</span> map4 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'e</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map4 f p q r s</code> returns a new parser encapsulating value <code>e</code> where,</p><ul><li><code>p</code>, <code>q</code>, <code>r</code> and <code>s</code> are evaluated sequentially in order as given.</li><li><code>a, b, c, d</code> are the parsed values of parsers <code>p</code>, <code>q</code>, <code>r</code> and <code>s</code> respectively.</li><li><code>e</code> is <code>f a b c d</code>.</li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let f a b c d = a + b + c + d in
let p = P.pure 1 in
let q = P.pure 2 in
let r = P.pure 3 in
let s = P.pure 4 in
let p = P.map4 f p q r s in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></div></div><div><div class="spec value" id="val-delay" class="anchored"><a href="#val-delay" class="anchor"></a><code><span class="keyword">val</span> delay : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Lazy.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>delay p</code> returns a parser which lazily parses <code>p</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(delay (lazy (char 'z')) &lt;|&gt; delay (lazy (char 'a'))) in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre></div></div><div><div class="spec value" id="val-named" class="anchored"><a href="#val-named" class="anchor"></a><code><span class="keyword">val</span> named : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>named name p</code> uses <code>name</code> as part of an error message when constructing exception <a href="index.html#exception-Parser"><code>Parser</code></a> if parse of <code>p</code> fails.</p><p>Also see <a href="Infix/index.html#val-(&lt;?&gt;)"><code>Infix.(&lt;?&gt;)</code></a></p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(char 'a' |&gt; named &quot;parse_c&quot;) in
let v =
  try
    let _ = P.parse_string p &quot;zzd&quot; in
    assert false
  with
  | e -&gt; e
in
v
= P.Parser
    { offset = 0
    ; line_number = 0
    ; column_number = 0
    ; msg = &quot;[parse_c] Reparse.Parser.Parser(0, 0, 0, \&quot;[char] expected 'a'\&quot;)&quot;
    }</code></pre></div></div><h2 id="alternation"><a href="#alternation" class="anchor"></a>Alternation</h2><aside><p>One or the other.</p></aside><div><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>any l</code> parses the value of the first successful parser in list <code>l</code>.</p><p>Specified parsers in <code>l</code> are evaluated sequentially from left to right. A failed parser doesn't consume any input, i.e. <code>offset</code> is unaffected.</p><p>The parser fails if none of the parsers in <code>l</code> are evaluated successfully.</p><p>Examples</p><p>First successful parser result is returned</p><pre><code>module P = Reparse.Parser

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;zabc&quot; in
v = 'z'

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;xabc&quot; in
v = 'x'

;;
let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre><p>Parser fails when none of the parsers in <code>l</code> are successful.</p><pre><code>let p = P.(any [ char 'z'; char 'x'; char 'a' ]) in
let v =
  try
    let _ = P.parse_string p &quot;yyy&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><div><div class="spec value" id="val-alt" class="anchored"><a href="#val-alt" class="anchor"></a><code><span class="keyword">val</span> alt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>alt p q</code> is <code>p &lt;|&gt; q</code>.</p><p>See <a href="Infix/index.html#val-(&lt;|&gt;)"><code>Infix.(&lt;|&gt;)</code></a></p></div></div><h2 id="grouping"><a href="#grouping" class="anchor"></a>Grouping</h2><aside><p>Group parsers.</p></aside><div><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>all l</code> parses all parsers in <code>l</code> and returns the parsed values.</p><p>The parser only succeeds if and only if all of the parsers in <code>l</code> succeed.</p><p>Parsers in <code>l</code> are evaluated sequentially - from left to right.</p><p>Examples</p><p>All specified parsers succeed.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(all [ char 'a'; char 'b'; char 'c' ]) in
let v = P.parse_string p &quot;abc&quot; in
v = [ 'a'; 'b'; 'c' ]</code></pre><p>One of the specified parsers - <code>char 'c'</code> fails.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(all [ char 'a'; char 'b'; char 'c' ]) in
let v =
  try
    let _ = P.parse_string p &quot;abd&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><div><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>all_unit l</code> parses all parsers in <code>l</code> while discarding the parsed values.</p><p>Examples</p><p>All specified parsers succeed.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(all_unit [ char 'a'; char 'b'; char 'c' ]) in
let v = P.parse_string p &quot;abc&quot; in
v = ()</code></pre><p>One of the specified parsers - <code>char 'c'</code> - fails.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(all_unit [ char 'a'; char 'b'; char 'c' ]) in
let v =
  try
    let _ = P.parse_string p &quot;abd&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><h2 id="repetition"><a href="#repetition" class="anchor"></a>Repetition</h2><h3 id="recur"><a href="#recur" class="anchor"></a>Recur</h3><div><div class="spec value" id="val-recur" class="anchored"><a href="#val-recur" class="anchor"></a><code><span class="keyword">val</span> recur : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>recur f</code> returns a recursive parser. Function value <code>f</code> accepts a parser <code>p</code> as its argument and returns a parser <code>q</code>. Parser <code>q</code> in its definition can refer to <code>p</code> and <code>p</code> can refer to <code>q</code> in its own definition.</p><p>Such parsers are also known as a fixpoint or y combinator.</p></div></div><h3 id="skip"><a href="#skip" class="anchor"></a>Skip</h3><aside><p>Discards parsed values.</p></aside><div><div class="spec value" id="val-skip" class="anchored"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <span>?&#8288;at_least:int</span> <span>&#45;&gt;</span> <span>?&#8288;up_to:int</span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></div><div><p><code>skip ~at_least ~up_to p</code> repeatedly parses <code>p</code> and discards its value.</p><p>The lower and upper bound of repetition is specified by arguments <code>at_least</code> and <code>up_to</code> respectively. The default value of <code>at_least</code> is 0. The default value of <code>up_to</code> is unspecified, i.e. there is no upper limit.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>up_to</code> upper bound value is reached</li></ul><p>The parser encapsulates the count of times <code>p</code> was evaluated successfully.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(skip space) in
let v = P.parse_string p &quot;     &quot; in
v = 5</code></pre></div></div><div><div class="spec value" id="val-skip_while" class="anchored"><a href="#val-skip_while" class="anchor"></a><code><span class="keyword">val</span> skip_while : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></div><div><p><code>skip_while p ~while_</code> repeatedly parses <code>p</code> and discards its value if parser <code>while_</code> parses to value <code>true</code>.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li></ul><p><b>Note</b> <code>while_</code> does not consume input.</p><p>The parser encapsulates the count of times <code>p</code> was evaluated successfully.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(skip_while next ~while_:(is space)) in
let v = P.parse_string p &quot;     &quot; in
v = 5</code></pre></div></div><h3 id="take"><a href="#take" class="anchor"></a>Take</h3><aside><p>Collects parsed values</p></aside><div><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span>?&#8288;at_least:int</span> <span>&#45;&gt;</span> <span>?&#8288;up_to:int</span> <span>&#45;&gt;</span> <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>take ~at_least ~up_to ~sep_by p</code> repeatedly parses <code>p</code> and returns the parsed values.</p><p>The lower and upper bound of repetition is specified by arguments <code>at_least</code> and <code>up_to</code> respectively. The default value of <code>at_least</code> is <code>0</code>. The default value of <code>up_to</code> is unspecified, i.e. there is no upper limit.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>sep_by</code> evaluates to failure</li><li><code>up_to</code> upper boudn value is reached</li></ul><p>The parser fails if the count of repetition of <code>p</code> does not match the value specified by <code>at_least</code>.</p><p>Examples</p><p>Default behaviour.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take (char 'a')) in
let v = P.parse_string p &quot;aaaaa&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Specify <code>~sep_by</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Specify lower bound argument <code>at_least</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~at_least:3 ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a'; 'a'; 'a' ]</code></pre><p>Lower bound not met results in error.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~at_least:5 ~sep_by:(char ',') (char 'a')) in
let v =
  try
    let _ = P.parse_string p &quot;a,a,a,a&quot; in
    false
  with
  | _ -&gt; true
in
v = true</code></pre><p>Specify upper bound <code>up_to</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~up_to:3 ~sep_by:(char ',') (char 'a')) in
let v = P.parse_string p &quot;a,a,a,a,a&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></div></div><div><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>take_while ~sep_by p ~while_ p</code> repeatedly parses <code>p</code> and returns its value.</p><p><code>p</code> is evaluated if and only if <code>while_</code> evaluates to <code>true</code>.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li><li><code>sep_by</code> evaluates to failure</li></ul><p><b>Note</b> <code>while_</code> does not consume input.</p><p>Examples</p><p>Default behaviour.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take_while ~while_:(is_not (char 'b')) (char 'a')) in
let v = P.parse_string p &quot;aab&quot; in
v = [ 'a'; 'a' ]</code></pre><p>Specify <code>sep_by</code>.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take_while ~sep_by:(char ',') ~while_:(is_not (char 'b')) (char 'a')) in
let v = P.parse_string p &quot;a,a,ab&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></div></div><div><div class="spec value" id="val-take_between" class="anchored"><a href="#val-take_between" class="anchor"></a><code><span class="keyword">val</span> take_between : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>start:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>end_:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>take_between ~sep_by ~start ~end_ p</code> parses <code>start</code> and then repeatedly parses <code>p</code> while the parsed value of <code>p</code> doesn't equal to parsed value of <code>end_</code>. After the repetition end, it parses <code>end_</code>. The parser returns the list of parsed values of <code>p</code>.</p><p>Both <code>start</code> and <code>end_</code> parser values are discarded.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p>The repetition ends when one of the following occurs:</p><ul><li><code>p</code> evaluates to failure</li><li><code>end_</code> parsed value matches <code>p</code> parsed value</li><li><code>sep_by</code> evaluates to failure</li></ul><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p =
  P.(take_between ~sep_by:(char ',') ~start:(P.char '(') ~end_:(char ')') next)
in
let v = P.parse_string p &quot;(a,a,a)&quot; in
v = [ 'a'; 'a'; 'a' ]</code></pre></div></div><div><div class="spec value" id="val-take_while_cb" class="anchored"><a href="#val-take_while_cb" class="anchor"></a><code><span class="keyword">val</span> take_while_cb : <span>?&#8288;sep_by:<span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>while_:<span>bool <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span>on_take_cb:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></div><div><p><code>take_while_on ~sep_by ~while_ ~on_take p</code> repeatedly parses <code>p</code> and calls callback <code>on_take_cb</code> with the parsed value.</p><p><code>p</code> is evaluated if and only if <code>while_</code> evaluates to <code>true</code>.</p><p>If <code>sep_by</code> is specified then the evaluation of <code>p</code> must be followed by a successful evaluation of <code>sep_by</code>. The parsed value of <code>sep_by</code> is discarded.</p><p><code>p</code> is evaluated repeatedly. The repetition ends when one of the following occurs:</p><p><code>on_take_cb</code> is the callback function that is called every time <code>p</code> is evaluated.</p><ul><li><code>p</code> evaluates to failure</li><li><code>while_</code> returns <code>false</code></li><li><code>sep_by</code> evaluates to failure</li></ul><p><code>take_while_cb</code> is the general version of <a href="index.html#val-take_while"><code>take_while</code></a>. It allows to specify how the value <code>a</code> is to be collected.</p><p><b>Note</b> <code>while_</code> does not consume input.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let buf = Buffer.create 0 in
let on_take_cb a = Buffer.add_char buf a in
let p = P.(take_while_cb (char 'a') ~while_:(is_not (char 'b')) ~on_take_cb) in
let v = P.parse_string p &quot;aaab&quot; in
let s = Buffer.contents buf in
v = 3 &amp;&amp; s = &quot;aaa&quot;</code></pre></div></div><h2 id="optional"><a href="#optional" class="anchor"></a>Optional</h2><aside><p>Don't fail when parsing is not successful.</p></aside><div><div class="spec value" id="val-optional" class="anchored"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>optional p</code> parses <code>Some a</code> if successful and <code>None</code> otherwise. <code>a</code> is the parsed value of <code>p</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(optional (char 'a')) in
let v = P.parse_string p &quot;ab&quot; in
v = Some 'a'

;;
let p = P.(optional (char 'z')) in
let v = P.parse_string p &quot;ab&quot; in
v = None</code></pre></div></div><h2 id="query-input-state"><a href="#query-input-state" class="anchor"></a>Query Input state</h2><div><div class="spec value" id="val-is_eoi" class="anchored"><a href="#val-is_eoi" class="anchor"></a><code><span class="keyword">val</span> is_eoi : <span>bool <a href="index.html#type-t">t</a></span></code></div><div><p><code>is_eoi</code> parses to <code>true</code> if parser has reached end of input, <code>false</code> otherwise.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string is_eoi &quot;&quot;) in
v = true

;;
let v = P.(parse_string is_eoi &quot;a&quot;) in
v = false</code></pre></div></div><div><div class="spec value" id="val-eoi" class="anchored"><a href="#val-eoi" class="anchor"></a><code><span class="keyword">val</span> eoi : <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>eoi</code> parses end of input. Fails if parser is not at end of input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string eoi &quot;&quot;) in
v = ()

;;
let v =
  try
    let _ = P.(parse_string eoi &quot;a&quot;) in
    false
  with
  | _ -&gt; true
in
v = true</code></pre></div></div><div><div class="spec value" id="val-lnum" class="anchored"><a href="#val-lnum" class="anchor"></a><code><span class="keyword">val</span> lnum : <span>int <a href="index.html#type-t">t</a></span></code></div><div><p><code>lnum</code> parses the current line number of input. line number count start form <code>1</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(next *&gt; lnum) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 1</code></pre></div></div><div><div class="spec value" id="val-cnum" class="anchored"><a href="#val-cnum" class="anchor"></a><code><span class="keyword">val</span> cnum : <span>int <a href="index.html#type-t">t</a></span></code></div><div><p><code>cnum</code> parses the current column number. column number count start from <code>1</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(next *&gt; cnum) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 2</code></pre></div></div><div><div class="spec value" id="val-offset" class="anchored"><a href="#val-offset" class="anchor"></a><code><span class="keyword">val</span> offset : <span>int <a href="index.html#type-t">t</a></span></code></div><div><p><code>offset</code> parses the current input offset. offset count start from <code>0</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(next *&gt; offset) in
let v = P.parse_string ~track_lnum:true p &quot;bcb&quot; in
v = 1</code></pre></div></div><h2 id="boolean"><a href="#boolean" class="anchor"></a>Boolean</h2><aside><p><code>true</code>, <code>false</code>, is, is not.</p></aside><div><div class="spec value" id="val-not_" class="anchored"><a href="#val-not_" class="anchor"></a><code><span class="keyword">val</span> not_ : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>not_ p</code> parses value <code>()</code> if and only if <code>p</code> fails to parse, otherwise the parse fails.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(not_ (char 'a')) in
let v = P.parse_string p &quot;bbb&quot; in
v = ()</code></pre></div></div><div><div class="spec value" id="val-not_followed_by" class="anchored"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>not_followed_by p q</code> parses value of <code>p</code> only if immediate and subsequent parse of <code>q</code> is a failure. Parser <code>q</code> doesn't consumes any input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(not_followed_by (char 'a') (char 'a')) in
let v = P.parse_string p &quot;ab&quot; in
v = 'a'</code></pre></div></div><div><div class="spec value" id="val-is_not" class="anchored"><a href="#val-is_not" class="anchor"></a><code><span class="keyword">val</span> is_not : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-t">t</a></span></code></div><div><p><code>is_not p</code> parses value <code>true</code> if <code>p</code> fails to parse and <code>false</code> otherwise. <b>Note</b> evaluating <code>p</code> doesn't consume any input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(is_not (char 'a')) in
let v = P.parse_string p &quot;bbb&quot; in
v = true</code></pre></div></div><div><div class="spec value" id="val-is" class="anchored"><a href="#val-is" class="anchor"></a><code><span class="keyword">val</span> is : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-t">t</a></span></code></div><div><p><code>is p</code> parses <code>true</code> if <code>p</code> is successful, <code>false</code> otherwise. <b>Note</b> evaluation of <code>p</code> doesn't consume any input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(is (char 'b')) in
let v = P.parse_string p &quot;bcb&quot; in
v = true</code></pre></div></div><h2 id="text"><a href="#text" class="anchor"></a>Text</h2><aside><p>Text parsing.</p></aside><div><div class="spec value" id="val-peek_char" class="anchored"><a href="#val-peek_char" class="anchor"></a><code><span class="keyword">val</span> peek_char : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>peek_char t</code> parses the next character from input without consuming it.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.peek_char in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre><p>Input is not consumed.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(peek_char *&gt; offset) in
let v = P.parse_string p &quot;hello&quot; in
v = 0</code></pre></div></div><div><div class="spec value" id="val-peek_string" class="anchored"><a href="#val-peek_string" class="anchor"></a><code><span class="keyword">val</span> peek_string : int <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></div><div><p><code>peek_string n</code> parse a string of length <code>n</code> without consuming it.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.peek_string 5 in
let v = P.parse_string p &quot;hello&quot; in
v = &quot;hello&quot;</code></pre><p>Input is not consumed.</p><pre><code>module P = Reparse.Parser

;;
let p = P.(peek_string 5 *&gt; offset) in
let v = P.parse_string p &quot;hello&quot; in
v = 0</code></pre></div></div><div><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>next</code> parses the next character from input. Fails if input has reached end of input.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string next &quot;hello&quot;) in
v = 'h'</code></pre></div></div><div><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>char c</code> parses character <code>c</code> exactly.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.char 'h' in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre></div></div><div><div class="spec value" id="val-char_if" class="anchored"><a href="#val-char_if" class="anchor"></a><code><span class="keyword">val</span> char_if : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>char_if f</code> parses a character <code>c</code> if <code>f c</code> is <code>true</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p =
  P.char_if (function
      | 'a' -&gt; true
      | _ -&gt; false)
in
let v = P.parse_string p &quot;abc&quot; in
v = 'a'</code></pre></div></div><div><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>?&#8288;case_sensitive:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></div><div><p><code>string ~case_sensitive s</code> parses a string <code>s</code> exactly.</p><p>If <code>case_sensitive</code> is <code>false</code> then comparison is done without character case consideration. Default value is <code>true</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.string &quot;hello&quot; in
let v = P.parse_string p &quot;hello world&quot; in
v = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-string_of_chars" class="anchored"><a href="#val-string_of_chars" class="anchor"></a><code><span class="keyword">val</span> string_of_chars : <span>char list</span> <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></div><div><p><code>string_of_chars l</code> converts <code>char list</code> <code>l</code> to string</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ~sep_by:space next &gt;&gt;= string_of_chars) in
let v = P.parse_string p &quot;h e l l o&quot; in
v = &quot;hello&quot;</code></pre></div></div><div><div class="spec value" id="val-line" class="anchored"><a href="#val-line" class="anchor"></a><code><span class="keyword">val</span> line : <span>[ `LF <span>| `CRLF</span> ]</span> <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></div><div><p><code>line c</code> parses a line of text from input.</p><p>Line delimiter <code>c</code> can be either <code>`LF</code> or <code>`CRLF</code>. This corresponds to <code>\n</code> or <code>\r\n</code> character respectively.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.line `CRLF in
let v = P.parse_string p &quot;line1\r\nline2&quot; in
v = &quot;line1&quot;</code></pre></div></div><h2 id="rfc5234"><a href="#rfc5234" class="anchor"></a>RFC 5234</h2><aside><p>Parsers as defined in RFC 5234, Appendix B.1.</p><dl><dt>see <a href="https://tools.ietf.org/html/rfc5234#appendix-B">https://tools.ietf.org/html/rfc5234#appendix-B</a></dt><dd></dd></dl></aside><div><div class="spec value" id="val-alpha" class="anchored"><a href="#val-alpha" class="anchor"></a><code><span class="keyword">val</span> alpha : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>alpha</code> parses a character in range <code>A- Z</code> or <code>a-z</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(take alpha) in
let v = P.parse_string p &quot;abcdABCD&quot; in
v = [ 'a'; 'b'; 'c'; 'd'; 'A'; 'B'; 'C'; 'D' ]</code></pre></div></div><div><div class="spec value" id="val-alpha_num" class="anchored"><a href="#val-alpha_num" class="anchor"></a><code><span class="keyword">val</span> alpha_num : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>alpha_num</code> parses a character in range <code>A-Z</code> or <code>a-z</code> or <code>0-9</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(take alpha_num) in
let v = P.parse_string p &quot;ab123ABCD&quot; in
v = [ 'a'; 'b'; '1'; '2'; '3'; 'A'; 'B'; 'C'; 'D' ]</code></pre></div></div><div><div class="spec value" id="val-lower_alpha" class="anchored"><a href="#val-lower_alpha" class="anchor"></a><code><span class="keyword">val</span> lower_alpha : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>lower_alpha</code> parses a character in range <code>a-z</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(take lower_alpha) in
let v = P.parse_string p &quot;abcd&quot; in
v = [ 'a'; 'b'; 'c'; 'd' ]</code></pre></div></div><div><div class="spec value" id="val-upper_alpha" class="anchored"><a href="#val-upper_alpha" class="anchor"></a><code><span class="keyword">val</span> upper_alpha : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>upper_alpha</code> parses a character in range <code>A-Z</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser
open P.Infix

;;
let p = P.(take upper_alpha) in
let v = P.parse_string p &quot;ABCD&quot; in
v = [ 'A'; 'B'; 'C'; 'D' ]</code></pre></div></div><div><div class="spec value" id="val-bit" class="anchored"><a href="#val-bit" class="anchor"></a><code><span class="keyword">val</span> bit : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>bit</code> parses a character which is either <code>'0'</code> or <code>'1'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take bit) in
let v = P.parse_string p &quot;0110 ab&quot; in
v = [ '0'; '1'; '1'; '0' ]</code></pre></div></div><div><div class="spec value" id="val-ascii_char" class="anchored"><a href="#val-ascii_char" class="anchor"></a><code><span class="keyword">val</span> ascii_char : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>ascii_char</code> parses any US-ASCII character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take ascii_char) in
let v = P.parse_string p &quot;0110 abc '&quot; in
v = [ '0'; '1'; '1'; '0'; ' '; 'a'; 'b'; 'c'; ' '; '\'' ]</code></pre></div></div><div><div class="spec value" id="val-cr" class="anchored"><a href="#val-cr" class="anchor"></a><code><span class="keyword">val</span> cr : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>cr</code> parses character <code>'\r'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string cr &quot;\rab&quot;) in
v = '\r'</code></pre></div></div><div><div class="spec value" id="val-crlf" class="anchored"><a href="#val-crlf" class="anchor"></a><code><span class="keyword">val</span> crlf : <span>string <a href="index.html#type-t">t</a></span></code></div><div><p><code>crlf</code> parses string <code>&quot;\r\n&quot;</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string crlf &quot;\r\n abc&quot;) in
v = &quot;\r\n&quot;</code></pre></div></div><div><div class="spec value" id="val-control" class="anchored"><a href="#val-control" class="anchor"></a><code><span class="keyword">val</span> control : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>control</code> parses characters in range <code>0x00 - 0x1F</code> or character <code>0x7F</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string control &quot;\x00&quot;) in
v = '\x00'</code></pre></div></div><div><div class="spec value" id="val-digit" class="anchored"><a href="#val-digit" class="anchor"></a><code><span class="keyword">val</span> digit : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>digit</code> parses one of the digit characters, <code>0 .. 9</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take digit) in
let v = P.parse_string p &quot;0123456789a&quot; in
v = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]</code></pre></div></div><div><div class="spec value" id="val-digits" class="anchored"><a href="#val-digits" class="anchor"></a><code><span class="keyword">val</span> digits : <span>string <a href="index.html#type-t">t</a></span></code></div><div><p><code>digits</code> parses one or more digit characters, <code>0 .. 9</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string digits &quot;1234 +&quot;) in
v = &quot;1234&quot;</code></pre></div></div><div><div class="spec value" id="val-dquote" class="anchored"><a href="#val-dquote" class="anchor"></a><code><span class="keyword">val</span> dquote : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>dquote</code> parses double quote character <code>'&quot;'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string dquote &quot;\&quot;hello &quot;) in
v = '&quot;'</code></pre></div></div><div><div class="spec value" id="val-hex_digit" class="anchored"><a href="#val-hex_digit" class="anchor"></a><code><span class="keyword">val</span> hex_digit : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>hex_digit</code> parses any of the hexadecimal digits - <code>0..9, A, B, C, D, E, F</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take hex_digit) in
let v = P.parse_string p &quot;0ABCDEFa&quot; in
v = [ '0'; 'A'; 'B'; 'C'; 'D'; 'E'; 'F' ]</code></pre></div></div><div><div class="spec value" id="val-htab" class="anchored"><a href="#val-htab" class="anchor"></a><code><span class="keyword">val</span> htab : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>htab</code> parses a horizontal tab character <code>'\t'</code>.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string htab &quot;\t&quot;) in
v = '\t'</code></pre></div></div><div><div class="spec value" id="val-lf" class="anchored"><a href="#val-lf" class="anchor"></a><code><span class="keyword">val</span> lf : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>lf</code> parses a linefeed <code>'\n'</code> character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string lf &quot;\n&quot;) in
v = '\n'</code></pre></div></div><div><div class="spec value" id="val-octet" class="anchored"><a href="#val-octet" class="anchor"></a><code><span class="keyword">val</span> octet : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>octect</code> parses any character in the range <code>\x00 - \xFF</code>. Synonym for <a href="index.html#val-next"><code>next</code></a></p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take octet) in
let v = P.parse_string p &quot;0110 abc '&quot; in
v = [ '0'; '1'; '1'; '0'; ' '; 'a'; 'b'; 'c'; ' '; '\'' ]</code></pre></div></div><div><div class="spec value" id="val-space" class="anchored"><a href="#val-space" class="anchor"></a><code><span class="keyword">val</span> space : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>space</code> parses a space character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string space &quot; abc '&quot;) in
v = ' '</code></pre></div></div><div><div class="spec value" id="val-spaces" class="anchored"><a href="#val-spaces" class="anchor"></a><code><span class="keyword">val</span> spaces : <span><span>char list</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>spaces</code> parses one or more spaces.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let v = P.(parse_string spaces &quot;   abc&quot;) in
v = [ ' '; ' '; ' ' ]</code></pre></div></div><div><div class="spec value" id="val-vchar" class="anchored"><a href="#val-vchar" class="anchor"></a><code><span class="keyword">val</span> vchar : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>vchar</code> parses any of the visible - printable - characters.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take vchar) in
let v = P.parse_string p &quot;0110abc\x00&quot; in
v = [ '0'; '1'; '1'; '0'; 'a'; 'b'; 'c' ]</code></pre></div></div><div><div class="spec value" id="val-whitespace" class="anchored"><a href="#val-whitespace" class="anchor"></a><code><span class="keyword">val</span> whitespace : <span>char <a href="index.html#type-t">t</a></span></code></div><div><p><code>whitespace</code> parses a space <code>' '</code> or horizontal tab <code>'\t'</code> character.</p><p>Examples</p><pre><code>module P = Reparse.Parser

;;
let p = P.(take whitespace) in
let v = P.parse_string p &quot;\t \t &quot; in
v = [ '\t'; ' '; '\t'; ' ' ]</code></pre></div></div><h2 id="infix"><a href="#infix" class="anchor"></a>Infix</h2><div><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>Provides functions to support infix and let syntax operators.</p></div></div><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><h3 id="calculator"><a href="#calculator" class="anchor"></a>Calculator</h3><aside><p>An example calculator that supports <code>+,-,*</code> and <code>/</code> calculations.</p><p>The expression grammar is defined by the following BNF grammar:</p><pre>&lt;expr&gt;   ::= &lt;term&gt;   &quot;+&quot; &lt;expr&gt; 
           | &lt;term&gt;
&lt;term&gt;   ::= &lt;factor&gt; &quot;*&quot; &lt;term&gt; 
           | &lt;factor&gt;
&lt;factor&gt; ::= &quot;(&quot; &lt;expr&gt; &quot;)&quot; 
           | integer</pre><pre><code> module P = Reparse.Parser
 open P.Infix

 type expr =
   | Int of int
   | Add of expr * expr
   | Sub of expr * expr
   | Mult of expr * expr
   | Div of expr * expr

 let skip_spaces = P.skip P.space

 let binop : 'a P.t -&gt; char -&gt; 'b P.t -&gt; ('a -&gt; 'b -&gt; 'c) -&gt; 'c P.t =
  fun exp1 op exp2 f -&gt;
   P.map3
     (fun e1 _ e2 -&gt; f e1 e2)
     exp1
     (skip_spaces *&gt; P.char op &lt;* skip_spaces)
     exp2
;;

 let integer : expr P.t =
   let+ d = P.digits in
   Int (int_of_string d)
 ;;

 let factor : expr P.t -&gt; expr P.t =
  fun expr -&gt;
   P.any
     [ P.char '(' *&gt; skip_spaces *&gt; expr &lt;* skip_spaces &lt;* P.char ')'
     ; skip_spaces *&gt; integer &lt;* skip_spaces
     ]
;;

 let term : expr P.t -&gt; expr P.t =
  fun factor -&gt;
   P.recur (fun term -&gt;
       let mult = binop factor '*' term (fun e1 e2 -&gt; Mult (e1, e2)) in
       let div = binop factor '/' term (fun e1 e2 -&gt; Div (e1, e2)) in
       mult &lt;|&gt; div &lt;|&gt; factor)
;;

 let expr : expr P.t =
   P.recur (fun expr -&gt;
       let factor = factor expr in
       let term = term factor in
       let add = binop term '+' expr (fun e1 e2 -&gt; Add (e1, e2)) in
       let sub = binop term '-' expr (fun e1 e2 -&gt; Sub (e1, e2)) in
       P.any [ add; sub; term ])
 ;;

 let rec eval : expr -&gt; int = function
   | Int i -&gt; i
   | Add (e1, e2) -&gt; eval e1 + eval e2
   | Sub (e1, e2) -&gt; eval e1 - eval e2
   | Mult (e1, e2) -&gt; eval e1 * eval e2
   | Div (e1, e2) -&gt; eval e1 / eval e2
 ;;

 (* Test AST *)
 let r =
   let actual = P.parse_string expr &quot;1*2-4+3&quot; in
   let expected = Sub (Mult (Int 1, Int 2), Add (Int 4, Int 3)) in
   Bool.equal (expected = actual) true
 ;;

 (* Run the evaluator. *)
 let exp_result = eval (P.parse_string expr &quot;12+1*10&quot;) |&gt; Int.equal 22</code></pre></aside><h3 id="json"><a href="#json" class="anchor"></a>Json</h3><aside><p>Implements JSON parser as defined in https://tools.ietf.org/html/rfc8259.</p><p>Assumes UTF-8 character encoding. However, it doesn't do any validation.</p><p>Sample top_level inputs;</p><pre>  parse json_value &quot;true&quot;;;
  parse json_value &quot;false&quot;;;
  parse json_value &quot;null&quot;;;
  parse json_value &quot;123&quot;;;
  parse json_value &quot;123.345&quot;;;
  parse json_value &quot;123e123&quot;;;
  parse json_value &quot;123.33E123&quot;;;
  parse json_value {|{&quot;field1&quot;: 123,&quot;field2&quot;: &quot;value2&quot;}|};;
  parse json_value {|{&quot;field1&quot;:[123,&quot;hello&quot;,-123.23], &quot;field2&quot;:123} |};;
  parse json_value {|{&quot;field1&quot;:123, &quot;field2&quot;:123} |};;
  parse json_value {|[123,&quot;hello&quot;,-123.23, 123.33e13, 123E23] |};;</pre><pre><code>module P = Reparse.Parser
open P.Infix

type value =
  | Object of (string * value) list
  | Array of value list
  | Number of
      { negative : bool
      ; int : string
      ; frac : string option
      ; exponent : string option
      }
  | String of string
  | False
  | True
  | Null

let ws =
  P.skip
    (P.char_if (function
        | ' ' | '\t' | '\n' | '\r' -&gt; true
        | _ -&gt; false))
;;

let implode l = List.to_seq l |&gt; String.of_seq
let struct_char c = ws *&gt; P.char c &lt;* ws
let null_value = ws *&gt; P.string &quot;null&quot; *&gt; ws *&gt; P.pure Null
let false_value = ws *&gt; P.string &quot;false&quot; *&gt; ws *&gt; P.pure False
let true_value = ws *&gt; P.string &quot;true&quot; *&gt; ws *&gt; P.pure True
let sprintf = Printf.sprintf

let number_value =
  let* negative =
    P.optional (P.char '-')
    &gt;|= function
    | Some '-' -&gt; true
    | _ -&gt; false
  in
  let* int =
    let digits1_to_9 =
      P.char_if (function
          | '1' .. '9' -&gt; true
          | _ -&gt; false)
    in
    let num =
      P.map2
        (fun first_ch digits -&gt; sprintf &quot;%c%s&quot; first_ch digits)
        digits1_to_9
        P.digits
    in
    P.any [ P.string &quot;0&quot;; num ]
  in
  let* frac = P.optional (P.char '.' *&gt; P.digits) in
  let+ exponent =
    P.optional
      (let* e = P.char 'E' &lt;|&gt; P.char 'e' in
       let* sign = P.optional (P.char '-' &lt;|&gt; P.char '+') in
       let sign =
         match sign with
         | Some c -&gt; sprintf &quot;%c&quot; c
         | None -&gt; &quot;&quot;
       in
       let+ digits = P.digits in
       sprintf &quot;%c%s%s&quot; e sign digits)
  in
  Number { negative; int; frac; exponent }
;;

let string =
  let escaped =
    let ch =
      P.char '\\'
      *&gt; P.char_if (function
             | '&quot;' | '\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't' -&gt; true
             | _ -&gt; false)
      &gt;|= sprintf &quot;\\%c&quot;
    in
    let hex4digit =
      let+ hex =
        P.string &quot;\\u&quot; *&gt; P.take ~at_least:4 ~up_to:4 P.hex_digit &gt;|= implode
      in
      sprintf &quot;\\u%s&quot; hex
    in
    P.any [ ch; hex4digit ]
  in
  let unescaped =
    P.take_while
      ~while_:(P.is_not (P.any [ P.char '\\'; P.control; P.dquote ]))
      P.next
    &gt;|= implode
  in
  let+ str = P.dquote *&gt; P.take (P.any [ escaped; unescaped ]) &lt;* P.dquote in
  String.concat &quot;&quot; str
;;

let string_value = string &gt;|= fun s -&gt; String s

let json_value =
  P.recur (fun value -&gt;
      let value_sep = struct_char ',' in
      let object_value =
        let member =
          let* nm = string &lt;* struct_char ':' in
          let+ v = value in
          nm, v
        in
        let+ object_value =
          struct_char '{' *&gt; P.take member ~sep_by:value_sep &lt;* struct_char '}'
        in
        Object object_value
      in
      let array_value =
        let+ vals =
          struct_char '[' *&gt; P.take value ~sep_by:value_sep &lt;* struct_char ']'
        in
        Array vals
      in
      P.any
        [ object_value
        ; array_value
        ; number_value
        ; string_value
        ; false_value
        ; true_value
        ; null_value
        ])
;;

let parse s = P.parse_string json_value s</code></pre></aside></div></body></html>