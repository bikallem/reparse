<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Infix (reparse.Reparse.Parser.Infix)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">reparse</a> &#x00BB; <a href="../../index.html">Reparse</a> &#x00BB; <a href="../index.html">Parser</a> &#x00BB; Infix</nav><h1>Module <code>Parser.Infix</code></h1></header><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;&gt;= f</code> returns a new parser b where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Also known as <code>bind</code> operation.</p><h5 id="infix_bind_examples"><a href="#infix_bind_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let f a = P.pure (Char.code a) in
let p = P.char 'h' in
let p = p &gt;&gt;= f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></dd></dl><dl><dt class="spec value" id="val-(&gt;|=)"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;|= f</code> returns a new parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code>.</li><li><code>b</code> is <code>f a</code>.</li></ul><p>Also known as <code>map</code> operation.</p><h5 id="infix_map_examples"><a href="#infix_map_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let f a = Char.code a in
let p = P.char 'h' in
let p = p &gt;|= f in
let v = P.parse_string p &quot;hello&quot; in
v = 104</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>pf &lt;*&gt; q</code> returns a new parser encapsulating value <code>b</code> where</p><ul><li><code>pf</code> and <code>q</code> are evaluated sequentially in order as given.</li><li><code>f</code> is the parsed value of <code>pf</code></li><li><code>a</code> is the parsed value of <code>q</code></li><li><code>b</code> is <code>f a</code></li></ul><p>Also known as <code>Applicative</code> operation.</p><h5 id="infix_applicative_examples"><a href="#infix_applicative_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let f a = a + 2 in
let pf = P.pure f in
let q = P.pure 2 in
let p = pf &lt;*&gt; q in
let v = P.parse_string p &quot;hello&quot; in
v = 4</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;$)"><a href="#val-(&lt;$)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$) : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>v &lt;$ p</code> replaces the parse value of <code>p</code> with <code>v</code>.</p><h5 id="infix_replace_examples"><a href="#infix_replace_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let v = &quot;hello&quot; in
let p = P.char 'h' in
let p = v &lt;$ p in
let v2 = P.parse_string p &quot;hello&quot; in
v2 = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>f &lt;$&gt; p</code> returns a parser encapsulating value <code>b</code> where,</p><ul><li><code>a</code> is the parsed value of <code>p</code></li><li><code>b</code> is <code>f a</code></li></ul><p>This is the infix version of <a href="../index.html#val-map"><code>map</code></a>.</p><h5 id="infix_mapper_examples"><a href="#infix_mapper_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let f a = a ^ &quot; world&quot; in
let p = P.string &quot;hello&quot; in
let p = f &lt;$&gt; p in
let v = P.parse_string p &quot;hello&quot; in
v = &quot;hello world&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(*&gt;)"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span><span class="type-var">_</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>p *&gt; q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>, <code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is parsed value of <code>q</code>.</li><li>The parsed value of <code>p</code> is discarded.</li></ul><p>Also known as <code>discard left</code>.</p><h5 id="infix_discard_left_examples"><a href="#infix_discard_left_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let p = P.string &quot;world&quot; in
let q = P.pure &quot;hello&quot; in
let p = p *&gt; q in
let v = P.parse_string p &quot;world&quot; in
v = &quot;hello&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;* q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>, <code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is parsed value of <code>p</code>.</li><li>The parsed value of <code>q</code> is discarded.</li></ul><p>Also know as discard_right.</p><h5 id="infix_discard_right_examples"><a href="#infix_discard_right_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let p = P.string &quot;world&quot; in
let q = P.pure &quot;hello&quot; in
let p = p &lt;* q in
let v = P.parse_string p &quot;world&quot; in
v = &quot;world&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;|&gt;)"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;|&gt;) : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;|&gt; q</code> returns a parser encapsulating value <code>a</code> where,</p><ul><li><code>p</code>,<code>q</code> are evaluated sequentially in order as given.</li><li><code>a</code> is the parsed value of <code>p</code> if <code>p</code> is successful</li><li><code>a</code> is the parsed value of <code>q</code> if <code>p</code> is a failure and <code>q</code> is a success.</li><li>If both - <code>p</code> and <code>q</code> - fails, then the parser fails.</li></ul><h5 id="infix_alternate_examples"><a href="#infix_alternate_examples" class="anchor"></a>Examples</h5><p><code>p</code> fails and <code>q</code> succeeds, therefore we return <code>q</code>'s parsed value <code>'w'</code></p><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v = P.parse_string p &quot;world&quot; in
v = 'w'</code></pre><p><code>p</code> succeeds therefore we return its parsed value <code>'h'</code></p><pre><code class="ml">let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v = P.parse_string p &quot;hello&quot; in
v = 'h'</code></pre><p>The parser fails if both <code>p</code> and <code>q</code> fails.</p><pre><code class="ml">let p = P.char 'h' in
let q = P.char 'w' in
let p = p &lt;|&gt; q in
let v =
  try
    let _ = P.parse_string p &quot;&quot; in
    false
  with _ -&gt; true in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;?&gt; err_msg</code> parses <code>p</code> to value <code>a</code> and returns a new parser encapsulating <code>a</code>. If <code>p</code> is a failure, then it fails with error message <code>err_msg</code>.</p><p>Often used as a last choice in <code>&lt;|&gt;</code>, e.g. <code>a &lt;|&gt; b &lt;|&gt; c &lt;?&gt; &quot;expected a b c&quot;</code>.</p><h5 id="infix_error_named_examples"><a href="#infix_error_named_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let p = P.char 'h' &lt;|&gt; P.char 'w' in
let err_msg = &quot;[error]&quot; in
let p = p &lt;?&gt; err_msg in
let v =
  try
    let _ = P.parse_string p &quot;&quot; in
    false
  with
  | P.Parser
      {offset= 0; line_number= 0; column_number= 0; msg= &quot;[error]&quot;} -&gt;
      true
  | _ -&gt; false in
v = true</code></pre></dd></dl><dl><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>let*</code> is a let syntax binding for <a href="index.html#val-(&gt;&gt;=)"><code>(&gt;&gt;=)</code></a></p><h5 id="infix_let_bind_examples"><a href="#infix_let_bind_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let p =
  let* a = P.pure 5 in
  let total = a + 5 in
  P.pure total in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></dd></dl><dl><dt class="spec value" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span class="keyword">val</span> let+ : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p><code>let*</code> is a let syntax binding for <a href="index.html#val-(&gt;|=)"><code>(&gt;|=)</code></a></p><h5 id="infix_let_map_examples"><a href="#infix_let_map_examples" class="anchor"></a>Examples</h5><pre><code class="ml">module P = Reparse.Parser
open P.Infix

;;
let p =
  let+ a = P.pure 5 in
  let total = a + 5 in
  total in
let v = P.parse_string p &quot;&quot; in
v = 10</code></pre></dd></dl></div></body></html>